<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Finance Manager</title>
<link rel="stylesheet" href="styles.css">
<style>
body{margin:0;padding:0;}
/* header styling removed to inherit global */
.tabs{display:flex;gap:0;padding:0;background:#B5A89A;justify-content:center;width:100%;border-radius:0;margin:0;font-weight:bold;}
.tabs button{padding:0.7rem 1rem;border:none;cursor:pointer;background:transparent;color:#2B2C29;font-weight:bold;border-radius:0;transition:background .18s,color .18s;}
.tabs button:hover, .tabs button.active{background:#2B2C29;color:#E7E4D6;}
.tab-content{display:none;padding:1rem;}
.tab-content.active{display:block;}
table{border-collapse:collapse;width:100%;margin-top:1rem;font-size:0.9rem;}
th,td{border:1px solid #ccc;padding:0.25rem 0.5rem;}
#pots-display{display:flex;justify-content:space-between;margin:1rem;}
.pot-column{flex:1;display:flex;flex-wrap:wrap;gap:0.5rem;}
#saving-pots{justify-content:flex-end;}
.pot{border:1px solid #ccc;padding:0.5rem;width:120px;text-align:center;display:flex;flex-direction:column;align-items:center;gap:0.25rem;}
.pot-name{font-weight:bold;}
.pot.saving{background:#d4edda;}
.pot.debt{background:#f8d7da;}
.pot .actions{display:flex;gap:0.25rem;}
.pot .actions button{margin:0 2px;}
.toggle{cursor:pointer;padding:0.5rem;border-radius:4px;margin:1rem 0;text-align:center;}
.section-header{font-size:1.2rem;font-weight:bold;position:relative;}
.section-header .pin-star {
  position: absolute;
  top: 50%;
  right: 8px;
  transform: translateY(-50%);
  cursor: pointer;
  z-index: 10;
}
.section-header .pin-star svg {
  width: 16px;
  height: 16px;
}
.section-header .pin-star.pinned svg {
  fill: #F7F6F3;
  stroke: #2B2C29;
  stroke-width: 1;
}
.hidden{display:none!important;}
.budget-section{padding-bottom:1rem;margin-bottom:1rem;}
.code-section{padding-bottom:1rem;margin-bottom:1rem;}
#budgets table{resize:horizontal;overflow:auto;display:block;}
#budgets table tbody tr:nth-child(even){background:#f2f2f2;}
#budgets table tbody tr td:first-child{color:#007bff;}

/* Multi-column sort styling */
.sort-btn {
  margin-left: 5px;
  padding: 2px 5px;
  font-size: 12px;
  border: none;
  background: transparent;
  cursor: pointer;
  border-radius: 3px;
}
.sort-btn:hover {
  background: #f0f0f0;
}

/* Enhanced category selector styling */
.category-selector {
  min-width: 200px;
  font-family: inherit;
}

.category-selector option[value^="category:"] {
  font-weight: bold;
  background-color: #f8f9fa;
}

.category-selector option[value^="subcategory:"] {
  font-weight: normal;
  color: #666;
  background-color: #fff;
}

.category-display {
  font-size: 0.9em;
  color: #333;
  padding: 4px;
  background-color: #f8f9fa;
  border-radius: 3px;
  min-height: 20px;
}

/* Rule form styling */
.rule-sections {
  display: flex;
  gap: 2rem;
  margin-bottom: 2rem;
}

.rule-section {
  flex: 1;
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 1rem;
  background-color: #fafafa;
}

.rule-section-header {
  margin: 0 0 0.5rem 0;
  font-size: 1.1rem;
  font-weight: bold;
  padding: 0.5rem;
  border-radius: 5px;
  text-align: center;
}

.input-header {
  background-color: #e3f2fd;
  color: #1565c0;
  border: 1px solid #bbdefb;
}

.output-header {
  background-color: #e8f5e8;
  color: #2e7d32;
  border: 1px solid #c8e6c9;
}

.rule-section-desc {
  margin: 0 0 1rem 0;
  font-size: 0.9rem;
  color: #666;
  font-style: italic;
}

.rule-inputs {
  display: grid;
  grid-template-columns: 1fr;
  gap: 1rem;
  margin-bottom: 0;
  padding: 0;
  background-color: transparent;
  border-radius: 0;
}

.rule-inputs div {
  display: flex;
  flex-direction: column;
}

.rule-inputs label {
  font-weight: bold;
  margin-bottom: 0.25rem;
  color: #333;
}

.required {
  color: #dc3545;
  font-weight: bold;
}

.rule-inputs input,
.rule-inputs select {
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 3px;
  font-size: 0.9rem;
}

/* Responsive design for smaller screens */
@media (max-width: 768px) {
  .rule-sections {
    flex-direction: column;
    gap: 1rem;
  }
}

#rule-table {
  margin-top: 1rem;
}

#rule-table th {
  background-color: #f1f1f1;
  font-weight: bold;
  padding: 0.75rem 0.5rem;
}

/* Special styling for grouped table headers */
#rule-table thead:first-child th {
  background-color: #e9ecef;
  font-size: 0.9rem;
  font-style: italic;
  border-bottom: 1px solid #ccc;
}

#rule-table thead:first-child th:nth-child(1) {
  background-color: #e3f2fd;
  color: #1565c0;
}

#rule-table thead:first-child th:nth-child(2) {
  background-color: #e8f5e8;
  color: #2e7d32;
}

#rule-table td {
  padding: 0.5rem;
  vertical-align: middle;
}

/* Searchable dropdown styling */
.searchable-dropdown {
  position: relative;
  display: inline-block;
  width: 100%;
}

.searchable-dropdown-input {
  width: 100%;
  padding: 0.4rem;
  border: 1px solid #ccc;
  border-bottom: none;
  border-radius: 3px 3px 0 0;
  font-size: 0.9rem;
  box-sizing: border-box;
  background-color: #f9f9f9;
}

.searchable-dropdown-input:focus {
  outline: none;
  border-color: #007bff;
  background-color: #fff;
}

.searchable-dropdown-select {
  width: 100%;
  padding: 0.4rem;
  border: 1px solid #ccc;
  border-top: none;
  border-radius: 0 0 3px 3px;
  font-size: 0.9rem;
  box-sizing: border-box;
  background-color: #fff;
  min-height: 120px;
}

.searchable-dropdown-select:focus {
  outline: none;
  border-color: #007bff;
}

.searchable-dropdown-select option {
  padding: 0.3rem;
}

.searchable-dropdown-select option[style*="font-weight: bold"] {
  background-color: #f8f9fa !important;
}

.searchable-dropdown-select option[style*="color: rgb(102, 102, 102)"] {
  background-color: #fff !important;
}

/* Modal styling for category selector */
.category-modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
}

.category-modal-content {
  background-color: #fefefe;
  margin: 10% auto;
  padding: 20px;
  border: none;
  border-radius: 8px;
  width: 400px;
  max-width: 90%;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.category-modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  border-bottom: 1px solid #eee;
  padding-bottom: 10px;
}

.category-modal-close {
  color: #aaa;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  border: none;
  background: none;
}

.category-modal-close:hover {
  color: #000;
}

.category-select-button {
  background: #f8f9fa;
  border: 1px solid #ccc;
  padding: 0.4rem 0.6rem;
  border-radius: 3px;
  cursor: pointer;
  font-size: 0.85rem;
  min-width: 120px;
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  display: inline-block;
  margin-right: 5px;
}

.category-select-button:hover {
  background: #e9ecef;
}

.category-select-button.empty {
  color: #666;
  font-style: italic;
}

/* Table column sizing for Type/SubType */
table th:nth-child(6), /* Assuming Type/SubType is 6th column after checkbox, date, desc, amount, account */
table td:nth-child(6) {
  width: auto;
  white-space: nowrap;
  min-width: 120px;
}
</style>
</head>
<body>
<header>
  <h1>Finance Manager</h1>
</header>
<div id="nav-placeholder"></div>
<script src="nav-loader.js"></script>
<div class="tabs">
  <button id="tab-settings" type="button">Settings</button>
  <button id="tab-code" type="button">Code</button>
  <button id="tab-budgets" type="button">Budgets</button>
  <button id="tab-pots" type="button">Pots</button>
</div>
<div id="settings" class="tab-content active">
  <section>
    <div class="toggle section-header" onclick="toggle('upload-section')">
      Upload Transactions
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('upload-section')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="upload-section">
      <form id="upload-form">
        <label>Account Type
          <select id="account-type">
            <option value="TSB">TSB</option>
            <option value="Monzo">Monzo</option>
            <option value="Credit Card">Credit Card</option>
          </select>
        </label>
        <label>Account Name
          <select id="account-name" required></select>
        </label>
        <input type="file" id="file-input" accept=".csv,.xls,.xlsx" required>
        <button type="submit">Upload</button>
      </form>
      <div id="upload-msg"></div>
    </div>
  </section>

  <section>
    <div class="toggle section-header" onclick="toggle('accounts-section')">
      Account Management
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('accounts-section')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="accounts-section">
      <h3>Accounts</h3>
      <ul id="accounts-display"></ul>
      <input type="text" id="new-account" placeholder="Add account">
      <button id="add-account">Add</button>
      <datalist id="type-list"></datalist>
    </div>
  </section>

  <section>
    <div class="toggle section-header" onclick="toggle('budget-settings-section')">
      Budget Settings
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('budget-settings-section')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="budget-settings-section">
      <h3>Thirds</h3>
      <div id="upload-settings" class="settings-section"></div>
      
      <h3>Budget Categories & Sub-Budgets</h3>
      <p style="color: #666; font-size: 14px; margin-bottom: 20px;">
        Manage your budget categories and sub-budgets. Categories group related expenses, and sub-budgets track specific allocations within each category.
      </p>
      <div id="budget-settings" class="settings-section" style="margin-top: 20px;"></div>
      
      <h3>Budget Periods</h3>
      <p style="color: #666; font-size: 14px; margin-bottom: 20px;">
        Define custom budget periods to organize your financial planning across different timeframes.
      </p>
      <div style="margin-top: 20px;">
        <form id="period-form" style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
          <input type="date" id="period-start" required style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
          <input type="date" id="period-end" required style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
          <input type="month" id="period-month" required style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
          <button type="submit" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Add Period</button>
        </form>
        <table id="period-table" style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr style="background: #f8f9fa;">
              <th style="padding: 12px; text-align: left; border: 1px solid #ddd;">Start</th>
              <th style="padding: 12px; text-align: left; border: 1px solid #ddd;">End</th>
              <th style="padding: 12px; text-align: left; border: 1px solid #ddd;">Month</th>
              <th style="padding: 12px; text-align: left; border: 1px solid #ddd;">Actions</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>

  <section>
    <div class="toggle section-header" onclick="toggle('backup-section')">
      Back Up
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('backup-section')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="backup-section">
      <div style="margin: 20px 0;">
        <p>Create manual backups of your finance data for safekeeping.</p>
        <div style="display: flex; align-items: center; gap: 20px; margin: 15px 0;">
          <button id="backup-now-btn" type="button" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">
            üìÅ Back Up Now
          </button>
          <div id="backup-status" style="font-style: italic; color: #666;"></div>
        </div>
        <div id="last-backup-info" style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 14px;">
          <strong>Last Backup:</strong> <span id="last-backup-date">Never</span>
        </div>
      </div>
    </div>
  </section>
</div>
<div id="code" class="tab-content">
  <section>
    <div class="toggle section-header" onclick="toggle('tx-main')">
      Transactions
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('tx-main')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="tx-main">
      <label><input type="checkbox" id="filter-uncoded">Uncoded only</label>
      <button id="show-duplicates" type="button">Show Duplicates</button>
      <button id="download-excel" type="button">Download Excel</button>
      <button id="delete-selected" type="button">Delete Selected</button>
      <div id="filter-controls" style="margin-top:0.5rem;">
        <input type="text" id="search-text" placeholder="Search description or file">
        <select id="filter-account"><option value="">All accounts</option></select>
        <select id="filter-type"><option value="">All types</option><option value="__blank">Blank</option></select>
        <select id="filter-subtype"><option value="">All sub types</option><option value="__blank">Blank</option></select>
        <input type="date" id="filter-date-from">
        <input type="date" id="filter-date-to">
        <input type="number" id="filter-amount-min" placeholder="Min">
        <input type="number" id="filter-amount-max" placeholder="Max">
        <label><input type="checkbox" id="toggle-file">See File</label>
        <label><input type="checkbox" id="filter-duplicates">See Duplicates</label>
        <label><input type="checkbox" id="filter-unconfirmed">See Unconfirmed</label>
        <button id="apply-filters" type="button">Apply</button>
      </div>
      <div id="sort-help" style="margin: 10px 0; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 14px; color: #6c757d;">
        <strong>Multi-Column Sorting:</strong> Click column headers to sort. Hold <kbd style="background: #e9ecef; padding: 1px 4px; border-radius: 2px;">Ctrl</kbd> while clicking to add secondary sort criteria. Numbers show sort order.
        <button type="button" id="clear-sort" style="margin-left: 10px; padding: 2px 8px; font-size: 12px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">Clear Sort</button>
      </div>
      <table id="tx-table">
        <thead>
          <tr>
            <th><input type="checkbox" id="select-all"></th>
            <th>Date <button type="button" class="sort-btn" data-field="date">‚Üï</button></th>
            <th>Description <button type="button" class="sort-btn" data-field="description">‚Üï</button></th>
            <th>Amount <button type="button" class="sort-btn" data-field="amount">‚Üï</button></th>
            <th>Account <button type="button" class="sort-btn" data-field="accountName">‚Üï</button></th>
            <th class="file-col" style="display:none;">File <button type="button" class="sort-btn" data-field="sourceFile">‚Üï</button></th>
            <th class="file-col" style="display:none;">Uploaded <button type="button" class="sort-btn" data-field="uploadedAt">‚Üï</button></th>
            <th>Type/SubType</th>
            <th>Pot <button type="button" class="sort-btn" data-field="pot">‚Üï</button></th>
            <th>Action</th>
            <th>Transfer <button type="button" class="sort-btn" data-field="transfer">‚Üï</button></th>
            <th>Notes <button type="button" class="sort-btn" data-field="notes">‚Üï</button></th>
            <th>Month <button type="button" class="sort-btn" data-field="month">‚Üï</button></th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div id="duplicates-modal" style="display:none;position:fixed;top:10%;left:10%;right:10%;background:#fff;border:1px solid #ccc;padding:1rem;max-height:80%;overflow:auto;">
        <button id="close-duplicates" type="button">Close</button>
        <table id="duplicates-table">
          <thead>
            <tr><th>Date</th><th>Description</th><th>Amount</th><th>Account</th><th>File</th><th>Action</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>

  <section>
    <div class="toggle section-header" onclick="toggle('code-rules-main')">
      Autofill Rules
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('code-rules-main')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="code-rules-main">
      <div id="code-settings" class="settings-section"></div>
    </div>
  </section>
</div>

<div id="budgets" class="tab-content">
  <section>
    <div class="toggle section-header" onclick="toggle('budget-main')">
      Budgets
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('budget-main')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#F7F6F3" stroke="#2B2C29" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="budget-main">
      <label>Extra Display
        <select id="extra-display">
          <option value="merge">Merge extra</option>
          <option value="separate">Separate extra</option>
        </select>
      </label>
      <label>Budget Month
        <select id="budget-month-select">
          <option value="current">Current Month</option>
        </select>
      </label>
      <table id="budget-table">
        <thead>
          <tr><th>Name</th><th>Description</th><th>Amount</th><th>Recurring</th><th>Date</th><th></th><th>Archived</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <section>
    <div class="toggle section-header" onclick="toggle('overview-main')">
      Budget Overview
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('overview-main')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="overview-main">
      <label>Months
        <select id="overview-month" multiple size="4"></select>
      </label>
      <label><input type="checkbox" id="show-budgeted" checked>Show Budgeted</label>
      <label><input type="checkbox" id="show-remaining" checked>Show Remaining</label>
      <label><input type="checkbox" id="show-income">Show Income</label>
      <label><input type="checkbox" id="toggle-archived">View Archived Budgets</label>
      <label><input type="checkbox" id="show-subtypes" checked>Show Sub-Types</label>
      
      <h3>Expenses</h3>
      <table id="overview-table">
        <thead><tr></tr></thead>
        <tbody></tbody>
      </table>
      
      <h3>Income</h3>
      <table id="income-table">
        <thead><tr></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <section>
    <div class="toggle section-header" onclick="toggle('balance-main')">
      Balance Sheet
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('balance-main')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="balance-main">
      <form id="start-balance-form">
        <label>Starting Date <input type="date" id="start-balance-date"></label>
        <div id="start-balance-accounts"></div>
        <button type="submit">Save Starting Balances</button>
      </form>
      <div style="display: flex; gap: 15px; margin: 10px 0; align-items: center;">
        <label>Current Month
          <select id="balance-month"></select>
        </label>
        <label>Date Range
          <select id="balance-range" onchange="renderBalance()">
            <option value="7">7 months (3 past + current + 3 future)</option>
            <option value="5">5 months (2 past + current + 2 future)</option>
            <option value="3">3 months (1 past + current + 1 future)</option>
            <option value="12">12 months (6 past + current + 5 future)</option>
            <option value="24">24 months (12 past + current + 11 future)</option>
          </select>
        </label>
        <button type="button" onclick="debugBudgets()" style="background: #007bff; color: white; border: none; padding: 5px 10px; border-radius: 3px;">Debug Budgets</button>
      </div>
      <table id="balance-table">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </section>
</div>
<div id="pots" class="tab-content">
  <section>
    <div class="toggle section-header" onclick="toggle('create-pots-section')">
      Create Pots
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('create-pots-section')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="create-pots-section">
      <form id="pot-form" class="form-grid">
        <label>Kind
          <select id="pot-kind">
            <option value="saving">Saving</option>
            <option value="debt">Debt</option>
          </select>
        </label>
        <label>Name
          <input type="text" id="pot-name" placeholder="Name" required>
        </label>
        <label>Account
          <select id="pot-account"><option value="">No account</option></select>
        </label>
        <label>Description
          <input type="text" id="pot-desc" placeholder="Description">
        </label>
        <label>Start Date
          <input type="date" id="pot-start" required>
        </label>
        <label>End Date
          <input type="date" id="pot-end">
        </label>
        <label>Goal Amount
          <input type="number" id="pot-goal" placeholder="Goal Amount">
        </label>
        <label>Monthly Target
          <input type="number" id="pot-target" placeholder="Monthly Target">
        </label>
        <label>Starting Amount
          <input type="number" id="pot-starting" placeholder="Starting Amount" required>
        </label>
        <label>Split pot?
          <input type="checkbox" id="pot-split">
        </label>
        <div id="subpot-container" style="display:none; margin-top:10px; border:1px dashed #ccc; padding:8px; border-radius:4px;">
          <div style="font-weight:bold; margin-bottom:6px;">Sub-pots</div>
          <div id="subpot-list" style="display:flex; flex-direction:column; gap:6px;"></div>
          <button type="button" id="add-subpot" style="margin-top:6px;">+ Add sub-pot</button>
        </div>
        <button type="submit" id="pot-submit">Create</button>
      </form>
    </div>
  </section>

  <section>
    <div class="toggle section-header" onclick="toggle('view-pots-section')">
      View Pots
      <span class="pin-star" onclick="event.stopPropagation(); togglePin('view-pots-section')" title="Pin section open">
        <svg viewBox="0 0 24 24" fill="#2B2C29" stroke="#F7F6F3" stroke-width="1">
          <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>
        </svg>
      </span>
    </div>
    <div id="view-pots-section">
      <div id="pots-display">
        <div id="debt-pots" class="pot-column"></div>
        <div id="saving-pots" class="pot-column"></div>
      </div>
    </div>
  </section>
</div>
<div id="pot-modal" style="display:none;position:fixed;top:10%;left:10%;right:10%;background:#fff;border:1px solid #ccc;padding:1rem;max-height:80%;overflow:auto;">
  <button type="button" id="close-pot-modal">Close</button>
  <button type="button" id="delete-pot">Delete</button>
  <form id="pot-view-form">
    <select id="view-pot-kind">
      <option value="saving">Saving</option>
      <option value="debt">Debt</option>
    </select>
    <input type="text" id="view-pot-name" placeholder="Name" required>
    <select id="view-pot-account"><option value="">No account</option></select>
    <input type="text" id="view-pot-desc" placeholder="Description">
    <input type="date" id="view-pot-start" required>
    <input type="date" id="view-pot-end">
    <input type="number" id="view-pot-goal" placeholder="Goal Amount">
    <input type="number" id="view-pot-target" placeholder="Monthly Target">
    <input type="number" id="view-pot-starting" placeholder="Starting Amount" required>
    <label style="display:inline-flex; align-items:center; gap:6px; margin-left:8px;">
      <input type="checkbox" id="view-pot-split"> Split pot?
    </label>
    <div id="view-subpot-container" style="display:none; margin-top:10px; border:1px dashed #ccc; padding:8px; border-radius:4px;">
      <div style="display:flex; gap:12px; align-items:center; margin-bottom:6px;">
        <div><strong>Assigned:</strong> ¬£<span id="view-assigned">0.00</span></div>
        <div><strong>Unallocated:</strong> ¬£<span id="view-unallocated">0.00</span></div>
      </div>
      <div id="view-subpot-list" style="display:flex; flex-direction:column; gap:6px;"></div>
      <button type="button" id="view-add-subpot" style="margin-top:6px;">+ Add sub-pot</button>
      <div id="pending-allocations" style="margin-top:10px; display:none; border-top:1px solid #eee; padding-top:8px;"></div>
    </div>
    <button type="submit">Save</button>
  </form>
  <div><strong>Current Amount:</strong> ¬£<span id="view-pot-current"></span></div>
  <div id="pot-transactions"></div>
</div>
<div id="budget-modal" style="display:none;position:fixed;top:10%;left:10%;right:10%;background:#fff;border:1px solid #ccc;padding:1rem;max-height:80%;overflow:auto;"></div>
<script src="node_modules/papaparse/papaparse.min.js"></script>
<script src="node_modules/xlsx/dist/xlsx.full.min.js"></script>
<script>
let financeData = { accounts: [], transactions: [], nextTransactionId: 1, budgetCategories: [], budgets: [], nextBudgetId: 1, rules: [], budgetPeriods: [], categoryStarts: {}, pots: [], nextPotId: 1, backupInfo: { lastBackup: null }, nonDuplicateGroups: [] };
let lastTxCheckbox = null;
let txSortCriteria = []; // Array of {field, dir} objects for multi-column sorting
const isMobile = /Mobi|Android/i.test(navigator.userAgent);

function showTab(id){
  document.querySelectorAll('.tab-content').forEach(div=>div.classList.remove('active'));
  const el=document.getElementById(id);
  if(el) el.classList.add('active');
}

async function loadFinance(){
  console.log('Loading finance data...');
  const res = await fetch('/api/finance-data');
  financeData = await res.json();
  console.log('Raw finance data loaded:', financeData);
  console.log('Pots in loaded data:', financeData.pots ? financeData.pots.length : 'NO POTS ARRAY');
  console.log('Budgets in loaded data:', financeData.budgets ? financeData.budgets.length : 'NO BUDGETS ARRAY');
  console.log('Budget periods in loaded data:', financeData.budgetPeriods ? financeData.budgetPeriods.length : 'NO BUDGET PERIODS ARRAY');
  financeData.budgetCategories = financeData.budgetCategories || [];
  if(!financeData.budgetCategories.includes('Other \u2013 Budgeted')){
    financeData.budgetCategories.push('Other \u2013 Budgeted');
  }
  if(!financeData.budgetCategories.includes('Other \u2013 Not Budgeted')){
    financeData.budgetCategories.push('Other \u2013 Not Budgeted');
  }
  financeData.categoryStarts = financeData.categoryStarts || {};
  // Category-level Fixed flags
  financeData.categoryFixed = financeData.categoryFixed || {};
  financeData.budgets = (financeData.budgets || []).map(b=>{
    if(!b.versions){
      const start = b.date || new Date().toISOString().slice(0,10);
      const end = new Date(new Date(start).setFullYear(new Date(start).getFullYear()+100)).toISOString().slice(0,10);
      b.versions = [{ amount: b.amount || 0, start, end, interval: b.recurring ? 1 : 0, mode: 'within' }];
    }
    b.extras = b.extras || [];
    b.desc = b.desc || '';
    // Sub-budget level Fixed flag default
    b.fixed = !!b.fixed;
    normalizeVersions(b);
    return b;
  });
  financeData.budgetPeriods = financeData.budgetPeriods || [];
  financeData.budgetPeriods.forEach(p=>{
    if(p.label && !p.month){ p.month = p.label; delete p.label; }
    if(!p.end) p.end = p.start;
  });
  financeData.startBalances = financeData.startBalances || {date:'', accounts:{}};
  financeData.pots = financeData.pots || [];
  financeData.nextPotId = financeData.nextPotId || 1;
  financeData.backupInfo = financeData.backupInfo || { lastBackup: null };
  financeData.nonDuplicateGroups = financeData.nonDuplicateGroups || [];
  financeData.transactions = (financeData.transactions || []).map(tx=>{
    const d = parseDate(tx.date);
    tx.date = Number.isNaN(d.getTime()) ? '' : d.toISOString().slice(0,10);
    return tx;
  });
  financeData.pots.forEach(p=>{
    const total=financeData.transactions.filter(t=>t.potId===p.id)
      .reduce((s,t)=>s+(parseFloat(t.amount)||0),0);
    if(p.startAmount===undefined){
      p.startAmount=(parseFloat(p.current)||0)-total;
    }
  });
  applyRulesToAll();
  assignMonthsAll();
  await saveFinance();
  checkDuplicates();
  updateAccountList();
  renderTransactions();
  renderBudgets();
  populateBudgetMonths();
  renderRules();
  // Delay code settings render to ensure DOM is ready
  setTimeout(() => {
    renderCodeSettings();
    renderUploadSettings();
  }, 100);
  renderPeriods();
  renderStartBalances();
  populateOverviewMonths();
  populateBalanceMonths();
  populateBudgetMonths();
  renderOverview();
  renderBalance();
  renderPots();
  renderSettingsSections();
}

// --- Split pot helpers ---
function potTransactions(p){
  return financeData.transactions.filter(t=>t.potId===p.id);
}
function calcPotCurrent(p){
  const start = parseFloat(p.startAmount)||0;
  const total = potTransactions(p).reduce((s,t)=>s+(parseFloat(t.amount)||0),0);
  return parseFloat((start+total).toFixed(2));
}
function getSubpotSummary(p){
  const subPots = p.subPots||[];
  const assigned = subPots.reduce((s,sp)=>s+(parseFloat(sp.assignedAmount)||0),0);
  const current = calcPotCurrent(p);
  const unallocated = parseFloat((current - assigned).toFixed(2));
  return { current, assigned, unallocated };
}
function addSubpotRow(container){
  const row=document.createElement('div');
  row.className='subpot-row';
  row.style.display='grid';
  row.style.gridTemplateColumns='1fr 120px 120px auto';
  row.style.gap='6px';
  row.innerHTML=`
    <input class="subpot-label" placeholder="Label" required>
    <input class="subpot-start" type="number" step="0.01" placeholder="Start amount">
    <input class="subpot-goal" type="number" step="0.01" placeholder="Goal (optional)">
    <button type="button" class="remove-subpot">Remove</button>
  `;
  row.querySelector('.remove-subpot').addEventListener('click',()=>row.remove());
  container.appendChild(row);
}

function updateAccountList(){
  const sel = document.getElementById('account-name');
  if(sel){
    sel.innerHTML = '';
    financeData.accounts.forEach(a=>{
      const o=document.createElement('option');
      o.value=a; o.textContent=a; sel.appendChild(o);
    });
  }
  const ul = document.getElementById('accounts-display');
  if(ul){
    ul.innerHTML='';
    financeData.accounts.forEach(a=>{
      const li=document.createElement('li');
      li.textContent=a;
      const del=document.createElement('button');
      del.textContent='x';
      del.style.marginLeft='0.5rem';
      del.addEventListener('click',()=>{
        financeData.accounts=financeData.accounts.filter(ac=>ac!==a);
        updateAccountList();
        saveFinance();
      });
      li.appendChild(del);
      ul.appendChild(li);
    });
  }
  const filterSel = document.getElementById('filter-account');
  if(filterSel){
    filterSel.innerHTML = '<option value="">All accounts</option>';
    financeData.accounts.forEach(a=>{ const opt=document.createElement('option'); opt.value=a; opt.textContent=a; filterSel.appendChild(opt); });
  }
  const potSel = document.getElementById('pot-account');
  if(potSel){
    potSel.innerHTML = '<option value="">No account</option>';
    financeData.accounts.forEach(a=>{ const opt=document.createElement('option'); opt.value=a; opt.textContent=a; potSel.appendChild(opt); });
  }
  const viewPotSel = document.getElementById('view-pot-account');
  if(viewPotSel){
    viewPotSel.innerHTML = '<option value="">No account</option>';
    financeData.accounts.forEach(a=>{ const opt=document.createElement('option'); opt.value=a; opt.textContent=a; viewPotSel.appendChild(opt); });
  }
  const ruleAccountSel = document.getElementById('rule-account');
  if(ruleAccountSel){
    ruleAccountSel.innerHTML = '<option value="">Any account</option>';
    financeData.accounts.forEach(a=>{ const opt=document.createElement('option'); opt.value=a; opt.textContent=a; ruleAccountSel.appendChild(opt); });
  }
}

function parseDate(val){
  if(val === undefined || val === null || val === '') return new Date('');
  if(val instanceof Date) return val;
  if(typeof val === 'number'){
    // Excel stores dates as days since 1899-12-30
    return new Date(Math.round((val - 25569) * 86400 * 1000));
  }
  if(typeof val === 'string'){
    const s = val.trim();
    const parts = s.split(/[\/\-]/);
    if(parts.length >= 3 && parts[0].length <= 2 && parts[1].length <= 2){
      let [d,m,y] = parts;
      y = y.split(' ')[0];
      if(y.length === 2) y = '20'+y;
      return new Date(parseInt(y,10), parseInt(m,10)-1, parseInt(d,10));
    }
    const parsed = Date.parse(s);
    if(!Number.isNaN(parsed)) return new Date(parsed);
  }
  return new Date(val);
}

function getPotName(tx){
  const p = financeData.pots.find(p=>p.id===tx.potId);
  return (p ? p.name : '').toLowerCase();
}

// Format date as dd/mm/yyyy for display
function formatDateDisplay(dateStr) {
  if (!dateStr) return '';
  const date = parseDate(dateStr);
  if (isNaN(date.getTime())) return dateStr;
  
  const day = String(date.getDate()).padStart(2, '0');
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const year = date.getFullYear();
  
  return `${day}/${month}/${year}`;
}

// Custom date sort for chronological order
function customDateSort(dateA, dateB) {
  const a = parseDate(dateA);
  const b = parseDate(dateB);
  
  if (isNaN(a.getTime()) && isNaN(b.getTime())) return 0;
  if (isNaN(a.getTime())) return 1;
  if (isNaN(b.getTime())) return -1;
  
  // Sort chronologically: year first, then month, then day
  return a.getTime() - b.getTime();
}

function updateSortIndicators(){
  document.querySelectorAll('#tx-table thead .sort-btn').forEach(b=>{
    const field = b.dataset.field;
    const sortIndex = txSortCriteria.findIndex(s => s.field === field);
    
    if(sortIndex !== -1) {
      const criteria = txSortCriteria[sortIndex];
      const arrow = criteria.dir === 1 ? '‚ñ≤' : '‚ñº';
      const order = sortIndex === 0 ? '' : ` ${sortIndex + 1}`;
      b.textContent = arrow + order;
      b.style.fontWeight = 'bold';
      b.style.color = sortIndex === 0 ? '#007bff' : '#6c757d';
    } else {
      b.textContent = '‚Üï';
      b.style.fontWeight = 'normal';
      b.style.color = '';
    }
  });
}

function getMonth(dateStr){
  const d = parseDate(dateStr);
  if(Number.isNaN(d.getTime())) return '';
  const m = String(d.getMonth()+1).padStart(2,'0');
  const y = d.getFullYear();
  return `${m} ${y}`;
}

function formatMonth(month){
  if(!month) return '';
  const [m,y] = month.split(' ');
  const d = new Date(parseInt(y,10), parseInt(m,10)-1, 1);
  return d.toLocaleString('default', { month: 'long' }) + ' ' + String(d.getFullYear()).slice(-2);
}

function assignMonth(tx){
  if(!tx.date) { tx.month=''; return; }
  if(financeData.budgetPeriods && financeData.budgetPeriods.length){
    const d = parseDate(tx.date);
    const match = financeData.budgetPeriods.find(p=>d >= parseDate(p.start) && d <= parseDate(p.end));
    tx.month = match ? match.month : '';
  } else {
    tx.month = '';
  }
}

function assignMonthsAll(){
  financeData.transactions.forEach(t=>assignMonth(t));
}

function normalizeVersions(sub){
  if(!sub.versions) return;
  sub.versions.sort((a,b)=>parseDate(a.start)-parseDate(b.start));
  for(let i=1;i<sub.versions.length;i++){
    const prev=sub.versions[i-1];
    const curr=sub.versions[i];
    if(parseDate(curr.start)<=parseDate(prev.end)){
      prev.end=new Date(parseDate(curr.start).getTime()-86400000).toISOString().slice(0,10);
    }
  }
  sub.versions.forEach((v,i)=>v.version=i+1);
}

function applyRules(tx){
  const matches = [];
  financeData.rules.forEach(r=>{
    if(r.match && (!tx.description || !tx.description.toLowerCase().includes(r.match.toLowerCase()))) return;
    if(r.account && tx.accountName!==r.account) return;
    if(r.amount!=null && parseFloat(tx.amount)!==r.amount) return;
    matches.push(r);
  });
  if(matches.length===1){
    const rule = matches[0];
    tx.type = rule.type;
    tx.subType = rule.subType || '';
    if(rule.potId!=null) tx.potId = rule.potId;
    if(rule.notes!=null) tx.notes = rule.notes;
    tx.autofill = true;
    tx.confirmed = false;
    delete tx.multipleRules;
  } else if(matches.length>1){
    tx.multipleRules = matches.map(m=>m.id);
    tx.autofill = true;
    tx.confirmed = false;
  }
}

function applyRulesToAll(){
  financeData.transactions.forEach(tx=>{
    if(!tx.type){
      applyRules(tx);
    }
  });
}

function checkDuplicates(){
  // First, reset all duplicate flags
  financeData.transactions.forEach(tx => {
    tx.duplicate = false;
  });
  
  // Then find and mark actual duplicates
  const seen = {};
  financeData.transactions.forEach(tx=>{
    const key = tx.date+'|'+tx.description+'|'+tx.amount+'|'+tx.accountName;
    
    // Check if this group has been marked as "keep all" (not duplicates)
    if(financeData.nonDuplicateGroups.includes(key)) {
      return; // Skip duplicate detection for this group
    }
    
    if(seen[key]){
      // Mark both the current transaction and the previously seen one as duplicates
      tx.duplicate = true;
      seen[key].forEach(prevTx => {
        prevTx.duplicate = true;
      });
      seen[key].push(tx);
    } else {
      seen[key] = [tx];
    }
  });
}

function applyBulkChange(tx, updater, alwaysRender){
  const selected = Array.from(document.querySelectorAll('#tx-table tbody .tx-select:checked'));
  const isSelected = selected.some(cb => parseInt(cb.dataset.id) === tx.id);
  let multi = false;
  if(isSelected && selected.length > 1){
    if(confirm('Apply this change to all selected transactions?')){
      const ids = selected.map(cb=>parseInt(cb.dataset.id));
      financeData.transactions.forEach(t=>{
        if(ids.includes(t.id)) updater(t);
      });
      multi = true;
    } else {
      updater(tx);
    }
  } else {
    updater(tx);
  }
  saveFinance();
  if(alwaysRender || multi) renderTransactions();
}

function renderTransactions(){
  const tbody = document.querySelector("#tx-table tbody");
  tbody.innerHTML = "";
  const selAll=document.getElementById('select-all');
  if(selAll) selAll.checked=false;
  const uncoded = document.getElementById("filter-uncoded").checked;
  const showDuplicates = document.getElementById("filter-duplicates") ? document.getElementById("filter-duplicates").checked : false;
  const showUnconfirmed = document.getElementById("filter-unconfirmed") ? document.getElementById("filter-unconfirmed").checked : false;
  const search = document.getElementById('search-text').value.toLowerCase();
  const showFile = document.getElementById('toggle-file').checked;
  document.querySelectorAll('#tx-table thead .file-col').forEach(th=>th.style.display=showFile?'':'none');
  const fAcc = document.getElementById('filter-account').value;
  const fType = document.getElementById('filter-type').value;
  const fSub = document.getElementById('filter-subtype').value;
  const fFrom = document.getElementById('filter-date-from').value;
  const fTo = document.getElementById('filter-date-to').value;
  const fMin = parseFloat(document.getElementById('filter-amount-min').value);
  const fMax = parseFloat(document.getElementById('filter-amount-max').value);
  const txs = [...financeData.transactions];
  if(txSortCriteria.length > 0){
    txs.sort((a,b)=>{
      for(let i = 0; i < txSortCriteria.length; i++) {
        const {field, dir} = txSortCriteria[i];
        let result = 0;
        
        if(field === 'date') {
          result = customDateSort(a.date, b.date);
        } else {
          let valA, valB;
          switch(field){
            case 'description': valA=(a.description||'').toLowerCase(); valB=(b.description||'').toLowerCase(); break;
            case 'amount': valA=parseFloat(a.amount)||0; valB=parseFloat(b.amount)||0; break;
            case 'accountName': valA=(a.accountName||'').toLowerCase(); valB=(b.accountName||'').toLowerCase(); break;
            case 'sourceFile': valA=(a.sourceFile||'').toLowerCase(); valB=(b.sourceFile||'').toLowerCase(); break;
            case 'uploadedAt': valA=parseDate(a.uploadedAt?a.uploadedAt.split('T')[0]:''); valB=parseDate(b.uploadedAt?b.uploadedAt.split('T')[0]:''); break;
            case 'type': valA=(a.type||'').toLowerCase(); valB=(b.type||'').toLowerCase(); break;
            case 'subType': valA=(a.subType||'').toLowerCase(); valB=(b.subType||'').toLowerCase(); break;
            case 'pot': valA=getPotName(a); valB=getPotName(b); break;
            case 'confirmed': valA=a.confirmed?1:0; valB=b.confirmed?1:0; break;
            case 'transfer': valA=a.transfer?1:0; valB=b.transfer?1:0; break;
            case 'notes': valA=(a.notes||'').toLowerCase(); valB=(b.notes||'').toLowerCase(); break;
            case 'month': valA=(a.month||'').toLowerCase(); valB=(b.month||'').toLowerCase(); break;
            default: valA=''; valB='';
          }
          if(valA < valB) result = -1;
          else if(valA > valB) result = 1;
          else result = 0;
        }
        
        if(result !== 0) {
          return result * dir;
        }
      }
      return 0; // If all criteria are equal
    });
  }
  txs.forEach(tx=>{
    if(uncoded && tx.type) return;
    if(showDuplicates && !tx.duplicate) return;
    if(showUnconfirmed && (tx.confirmed || (!tx.autofill && !tx.multipleRules))) return;
    if(fAcc && tx.accountName !== fAcc) return;
    if(fType === '__blank'){ if(tx.type) return; }
    else if(fType && tx.type !== fType) return;
    if(fSub === '__blank'){ if(tx.subType) return; }
    else if(fSub && tx.subType !== fSub) return;
    if(search){
      let text = (tx.description||'').toLowerCase();
      if(showFile){
        text += ' ' + (tx.sourceFile||'').toLowerCase() + ' ' + (tx.uploadedAt||'').toLowerCase();
      }
      if(!text.includes(search)) return;
    }
    if(fFrom && parseDate(tx.date) < parseDate(fFrom)) return;
    if(fTo && parseDate(tx.date) > parseDate(fTo)) return;
    if(!Number.isNaN(fMin) && parseFloat(tx.amount) < fMin) return;
    if(!Number.isNaN(fMax) && parseFloat(tx.amount) > fMax) return;
    const tr = document.createElement("tr");
    const fileCells = showFile ?
      `<td class="file-col">${tx.sourceFile||''}</td><td class="file-col">${tx.uploadedAt?tx.uploadedAt.split('T')[0]:''}</td>` :
      `<td class="file-col" style="display:none;">${tx.sourceFile||''}</td><td class="file-col" style="display:none;">${tx.uploadedAt?tx.uploadedAt.split('T')[0]:''}</td>`;
    tr.innerHTML = `<td><input type="checkbox" class="tx-select" data-id="${tx.id}"></td>`+
      `<td>${formatDateDisplay(tx.date)}</td><td>${tx.description}</td><td>${tx.amount}</td><td>${tx.accountName}</td>` + fileCells;
    const cb = tr.querySelector('.tx-select');
    cb.addEventListener('click', e=>{
      if(e.shiftKey && lastTxCheckbox){
        const boxes = Array.from(document.querySelectorAll('#tx-table tbody .tx-select'));
        const start = boxes.indexOf(lastTxCheckbox);
        const end = boxes.indexOf(cb);
        const [min,max] = start < end ? [start,end] : [end,start];
        const check = cb.checked;
        for(let i=min;i<=max;i++){ boxes[i].checked = check; }
      }
      lastTxCheckbox = cb;
    });
    if(tx.duplicate) tr.style.background = "#fdd";
    if(tx.autofill && !tx.confirmed) tr.style.background = "#ffffcc";
    if(tx.multipleRules && tx.multipleRules.length>1) tr.style.background = "#fcc";
    // Create a compact category selector button that opens a modal
    let categorySelector = createCategoryModalSelector(
      tx.type || '', 
      tx.subType || '', 
      (newType, newSubType) => {
        applyBulkChange(tx, t => { 
          t.type = newType; 
          t.subType = newSubType; 
          t.confirmed = true; 
          t.autofill = false; 
        }, true);
        updateCategoryDisplay();
      }
    );
    
    function populateCategorySelector(){
      // Update the button display with current values
      categorySelector.updateValues(tx.type || '', tx.subType || '');
    }
    
    populateCategorySelector();
    
    const transferBox = document.createElement("input");
    transferBox.type = "checkbox";
    transferBox.checked = !!tx.transfer;
    transferBox.addEventListener("change", ()=>{ applyBulkChange(tx, t=>{ t.transfer = transferBox.checked; }, false); });
    const notes = document.createElement("input");
    notes.value = tx.notes || "";
    notes.addEventListener("change", ()=>{ applyBulkChange(tx, t=>{ t.notes = notes.value; }, false); });
    const tdCategory = document.createElement("td"); 
    tdCategory.appendChild(categorySelector);
    tdCategory.style.whiteSpace = 'nowrap';
    tdCategory.style.width = 'auto';
    
    // Create a display cell for the current selection that shows both type and subtype
    const tdCategoryDisplay = document.createElement("td");
    tdCategoryDisplay.className = 'category-display';
    function updateCategoryDisplay() {
      const type = tx.type || '';
      const subType = tx.subType || '';
      if(subType) {
        tdCategoryDisplay.textContent = `${type} ‚Üí ${subType}`;
      } else if(type) {
        tdCategoryDisplay.textContent = type;
      } else {
        tdCategoryDisplay.textContent = '';
      }
    }
    updateCategoryDisplay();
    const potSel = document.createElement('select');
    const blankPot = document.createElement('option'); blankPot.value=''; blankPot.textContent='';
    potSel.appendChild(blankPot);
    financeData.pots.forEach(p=>{ const o=document.createElement('option'); o.value=p.id; o.textContent=p.name; potSel.appendChild(o); });
    potSel.value = tx.potId || '';
    potSel.addEventListener('change', ()=>{
      const newId = potSel.value ? parseInt(potSel.value) : null;
      applyBulkChange(tx, t=>{ 
        t.potId = newId; 
        // If pointing to a split pot, mark as needing allocation
        const pot = financeData.pots.find(p=>p.id===newId);
        if(pot && pot.isSplit){ t.subPotId = null; }
        else { delete t.subPotId; }
      }, true);
      renderPots();
    });
    const tdPot = document.createElement('td'); tdPot.appendChild(potSel);
    // Add indicator if split pot needs allocation
    const selPot = financeData.pots.find(p=>p.id==tx.potId);
    if(selPot && selPot.isSplit && !tx.subPotId){
      const badge=document.createElement('div');
      badge.textContent='Needs allocation';
      badge.style.cssText='margin-top:4px; font-size:11px; color:#b36b00; background:#fff7e6; border:1px solid #ffd591; border-radius:3px; padding:1px 4px; display:inline-block;';
      tdPot.appendChild(badge);
    }
    
    // Create action button cell (replaces the confirmed checkbox)
    const tdAction = document.createElement("td"); 
    tdAction.style.textAlign = 'center';
    
    if(tx.duplicate) {
      // Show duplicate resolution button
      const duplicateBtn = document.createElement('button');
      duplicateBtn.innerHTML = '‚ö†Ô∏è';
      duplicateBtn.title = 'Resolve duplicate';
      duplicateBtn.style.background = 'none';
      duplicateBtn.style.border = 'none';
      duplicateBtn.style.fontSize = '16px';
      duplicateBtn.style.cursor = 'pointer';
      duplicateBtn.addEventListener('click', () => {
        showDuplicateModal(tx);
      });
      tdAction.appendChild(duplicateBtn);
    } else if(tx.autofill && !tx.confirmed) {
      // Show confirm autocoding button
      const confirmBtn = document.createElement('button');
      confirmBtn.innerHTML = '‚úì';
      confirmBtn.title = 'Confirm autocoding';
      confirmBtn.style.background = '#28a745';
      confirmBtn.style.color = 'white';
      confirmBtn.style.border = 'none';
      confirmBtn.style.borderRadius = '3px';
      confirmBtn.style.padding = '2px 6px';
      confirmBtn.style.cursor = 'pointer';
      confirmBtn.addEventListener('click', () => {
        applyBulkChange(tx, t => { 
          t.confirmed = true; 
          t.autofill = false; 
        }, true);
      });
      tdAction.appendChild(confirmBtn);
    } else if(tx.confirmed) {
      // Show confirmed status
      const confirmedIcon = document.createElement('span');
      confirmedIcon.innerHTML = '‚úÖ';
      confirmedIcon.title = 'Confirmed';
      tdAction.appendChild(confirmedIcon);
    }
    
    const tdTrans = document.createElement("td"); tdTrans.appendChild(transferBox);
    const tdNotes = document.createElement("td"); tdNotes.appendChild(notes);
    const tdMonth = document.createElement("td"); tdMonth.textContent = tx.month || '';
    tr.appendChild(tdCategory); tr.appendChild(tdPot); tr.appendChild(tdAction); tr.appendChild(tdTrans); tr.appendChild(tdNotes); tr.appendChild(tdMonth);
    tbody.appendChild(tr);
  });
  updateSortIndicators();
  populateBalanceMonths();
  renderBalance();
}

// Show modal to resolve duplicates
function showDuplicateModal(duplicateTx) {
  // Find all transactions that are duplicates of this one
  const duplicateKey = duplicateTx.date + '|' + duplicateTx.description + '|' + duplicateTx.amount + '|' + duplicateTx.accountName;
  const duplicates = financeData.transactions.filter(tx => {
    const key = tx.date + '|' + tx.description + '|' + tx.amount + '|' + tx.accountName;
    return key === duplicateKey;
  });

  // Create modal HTML
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  `;

  const content = document.createElement('div');
  content.style.cssText = `
    background: white;
    padding: 20px;
    border-radius: 8px;
    max-width: 80%;
    max-height: 80%;
    overflow: auto;
  `;

  content.innerHTML = `
    <h3>Resolve Duplicate Transactions</h3>
    <p>The following transactions appear to be duplicates:</p>
    <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
      <thead>
        <tr style="background: #f0f0f0;">
          <th style="border: 1px solid #ddd; padding: 8px;">Date</th>
          <th style="border: 1px solid #ddd; padding: 8px;">Description</th>
          <th style="border: 1px solid #ddd; padding: 8px;">Amount</th>
          <th style="border: 1px solid #ddd; padding: 8px;">Account</th>
          <th style="border: 1px solid #ddd; padding: 8px;">Source File</th>
          <th style="border: 1px solid #ddd; padding: 8px;">Action</th>
        </tr>
      </thead>
      <tbody>
        ${duplicates.map(tx => `
          <tr>
            <td style="border: 1px solid #ddd; padding: 8px;">${formatDateDisplay(tx.date)}</td>
            <td style="border: 1px solid #ddd; padding: 8px;">${tx.description}</td>
            <td style="border: 1px solid #ddd; padding: 8px;">${tx.amount}</td>
            <td style="border: 1px solid #ddd; padding: 8px;">${tx.accountName}</td>
            <td style="border: 1px solid #ddd; padding: 8px;">${tx.sourceFile || 'Manual'}</td>
            <td style="border: 1px solid #ddd; padding: 8px;">
              <button onclick="resolveDuplicate(${tx.id}, 'keep')" style="background: #28a745; color: white; border: none; padding: 4px 8px; margin: 2px; border-radius: 3px; cursor: pointer;">Keep</button>
              <button onclick="resolveDuplicate(${tx.id}, 'delete')" style="background: #dc3545; color: white; border: none; padding: 4px 8px; margin: 2px; border-radius: 3px; cursor: pointer;">Delete</button>
            </td>
          </tr>
        `).join('')}
      </tbody>
    </table>
    <div style="margin-top: 20px;">
      <button onclick="resolveDuplicate(${duplicates[0].id}, 'keepall')" style="background: #17a2b8; color: white; border: none; padding: 8px 16px; margin: 4px; border-radius: 3px; cursor: pointer;">Keep All</button>
      <button onclick="closeDuplicateModal()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; margin: 4px; border-radius: 3px; cursor: pointer;">Cancel</button>
    </div>
  `;

  modal.appendChild(content);
  document.body.appendChild(modal);
  
  // Store modal reference for closing
  window.currentDuplicateModal = modal;
}

// Resolve duplicate action
function resolveDuplicate(txId, action) {
  if (action === 'delete' && txId) {
    // Delete this specific transaction
    financeData.transactions = financeData.transactions.filter(tx => tx.id !== txId);
  } else if (action === 'keep' && txId) {
    // Mark this transaction as not a duplicate
    const tx = financeData.transactions.find(t => t.id === txId);
    if (tx) tx.duplicate = false;
  } else if (action === 'keepall' && txId) {
    // Mark all transactions with this key as permanently not duplicates
    const tx = financeData.transactions.find(t => t.id === txId);
    if (tx) {
      const key = tx.date+'|'+tx.description+'|'+tx.amount+'|'+tx.accountName;
      if (!financeData.nonDuplicateGroups.includes(key)) {
        financeData.nonDuplicateGroups.push(key);
      }
    }
  }
  
  // Recheck duplicates after resolution
  checkDuplicates();
  saveFinance();
  renderTransactions();
  closeDuplicateModal();
}

// Close duplicate modal
function closeDuplicateModal() {
  if (window.currentDuplicateModal) {
    document.body.removeChild(window.currentDuplicateModal);
    window.currentDuplicateModal = null;
  }
}

function renderBudgets(){
  console.log('renderBudgets called');
  console.log('financeData.budgets:', financeData.budgets);
  const tbody = document.querySelector('#budget-table tbody');
  if(!tbody) {
    console.log('ERROR: budget-table tbody not found');
    return;
  }
  tbody.innerHTML = '';
  
  if (!financeData.budgets) {
    console.log('ERROR: financeData.budgets is undefined or null');
    return;
  }
  
  // Get selected month
  const monthSelect = document.getElementById('budget-month-select');
  const selectedMonth = monthSelect ? monthSelect.value : 'current';
  
  console.log('About to render budgets, budgets count:', financeData.budgets.length);
  const groups = {};
  financeData.budgets.forEach(b=>{
    groups[b.type] = groups[b.type] || { amount:0, items:[] };
    const v=budgetVersionForMonth(b, selectedMonth);
    groups[b.type].amount += v?parseFloat(v.amount||0):0;
    groups[b.type].items.push(b);
  });
  financeData.budgetCategories.forEach(cat=>{
    const g = groups[cat] || {amount:0, items:[]};
    const tr = document.createElement('tr');
    const delCatBtn = document.createElement('button');
    delCatBtn.textContent = 'Delete';
    if(!cat.startsWith('Other')){
      delCatBtn.addEventListener('click', ()=>{
        if(confirm('Delete category and all its sub budgets? This will remove related types from transactions.')){
          financeData.budgets = financeData.budgets.filter(b=>b.type!==cat);
          financeData.transactions.forEach(t=>{ if(t.type===cat){ t.type=''; t.subType=''; } });
          financeData.rules = financeData.rules.filter(r=>r.type!==cat);
          financeData.budgetCategories = financeData.budgetCategories.filter(c=>c!==cat);
          saveFinance();
          renderBudgets();
          renderOverview();
          renderTransactions();
          renderRules();
          updateTypeOptions();
          renderSettingsSections();
        }
      });
    } else {
      delCatBtn.disabled = true;
    }
    tr.appendChild(document.createElement('td')).textContent = cat;
    tr.appendChild(document.createElement('td')).textContent = '';
    tr.appendChild(document.createElement('td')).textContent = g.amount;
    tr.appendChild(document.createElement('td'));
    tr.appendChild(document.createElement('td'));
    const actionTd = document.createElement('td'); actionTd.appendChild(delCatBtn); tr.appendChild(actionTd);
    tr.appendChild(document.createElement('td'));
    tbody.appendChild(tr);
    g.items.forEach(sub=>{
      const tr2 = document.createElement('tr');
      const v=budgetVersionForMonth(sub, selectedMonth) || {amount:'',interval:1,mode:'within',start:'',end:''};
      tr2.innerHTML = `<td style="padding-left:20px;">${sub.name}</td><td>${sub.desc||''}</td><td>${v.amount}</td><td>${v.interval>1?`Every ${v.interval} (${v.mode})`:'Monthly'}</td><td>${v.start}</td>`;
      const editSubBtn=document.createElement('button');
      editSubBtn.textContent='Edit';
      editSubBtn.addEventListener('click',()=>openBudgetModal(sub));
      const delSubBtn = document.createElement('button');
      delSubBtn.textContent = 'Delete';
      delSubBtn.addEventListener('click',()=>{
        if(confirm('Delete this sub budget? This will remove it from any transactions.')){
          financeData.budgets = financeData.budgets.filter(b=>!(b.type===sub.type && b.name===sub.name));
          financeData.transactions.forEach(t=>{ if(t.type===sub.type && t.subType===sub.name){ t.type=''; t.subType=''; } });
          financeData.rules = financeData.rules.filter(r=>!(r.type===sub.type && r.subType===sub.name));
          saveFinance();
          renderBudgets();
          renderOverview();
          renderTransactions();
          renderRules();
          renderSettingsSections();
        }
      });
      const actionTd2 = document.createElement('td'); actionTd2.appendChild(editSubBtn); actionTd2.appendChild(delSubBtn); tr2.appendChild(actionTd2);
      const arch = document.createElement('input');
      arch.type = 'checkbox';
      arch.checked = !!sub.archived;
      arch.addEventListener('change',()=>{ sub.archived = arch.checked; saveFinance(); renderOverview(); });
      const tdArch = document.createElement('td'); tdArch.appendChild(arch); tr2.appendChild(tdArch);
      tbody.appendChild(tr2);
    });
  });

  const uncat = groups[''] || {amount:0, items:[]};
  if(uncat.items.length){
    const tr=document.createElement('tr');
    tr.appendChild(document.createElement('td')).textContent='Uncategorised';
    tr.appendChild(document.createElement('td')).textContent='';
    tr.appendChild(document.createElement('td')).textContent=uncat.amount;
    tr.appendChild(document.createElement('td'));
    tr.appendChild(document.createElement('td'));
    tr.appendChild(document.createElement('td'));
    tr.appendChild(document.createElement('td'));
    tbody.appendChild(tr);
    uncat.items.forEach(sub=>{
      const tr2=document.createElement('tr');
      const v=budgetVersionForMonth(sub, selectedMonth)||{amount:'',interval:1,mode:'within',start:'',end:''};
      tr2.innerHTML = `<td style="padding-left:20px;">${sub.name}</td><td>${sub.desc||''}</td><td>${v.amount}</td><td>${v.interval>1?`Every ${v.interval} (${v.mode})`:'Monthly'}</td><td>${v.start}</td>`;
      const editSubBtn=document.createElement('button');
      editSubBtn.textContent='Edit';
      editSubBtn.addEventListener('click',()=>openBudgetModal(sub));
      const delSubBtn=document.createElement('button');
      delSubBtn.textContent='Delete';
      delSubBtn.addEventListener('click',()=>{
        if(confirm('Delete this sub budget? This will remove it from any transactions.')){
          financeData.budgets = financeData.budgets.filter(b=>!(b.type===sub.type && b.name===sub.name));
          financeData.transactions.forEach(t=>{ if(t.type===sub.type && t.subType===sub.name){ t.type=''; t.subType=''; } });
          financeData.rules = financeData.rules.filter(r=>!(r.type===sub.type && r.subType===sub.name));
          saveFinance();
          renderBudgets();
          renderOverview();
          renderTransactions();
          renderRules();
          renderSettingsSections();
        }
      });
      const actionTd2=document.createElement('td'); actionTd2.appendChild(editSubBtn); actionTd2.appendChild(delSubBtn); tr2.appendChild(actionTd2);
      const arch=document.createElement('input');
      arch.type='checkbox';
      arch.checked=!!sub.archived;
      arch.addEventListener('change',()=>{ sub.archived=arch.checked; saveFinance(); renderOverview(); });
      const tdArch=document.createElement('td'); tdArch.appendChild(arch); tr2.appendChild(tdArch);
      tbody.appendChild(tr2);
    });
  }
  updateTypeOptions();
  renderBalance();
}

function updateTypeOptions(){
  const list = document.getElementById('type-list');
  if(list) list.innerHTML = '';
  const filter = document.getElementById('filter-type');
  if(filter) filter.innerHTML = '<option value="">All types</option><option value="__blank">Blank</option>';
  financeData.budgetCategories.forEach(t=>{
    if(list){ const opt=document.createElement('option'); opt.value=t; list.appendChild(opt); }
    if(filter){ const opt=document.createElement('option'); opt.value=t; opt.textContent=t; filter.appendChild(opt); }
  });
  const ruleType = document.getElementById('rule-type');
  if(ruleType){
    ruleType.innerHTML = '<option value="">Select type</option>';
    financeData.budgetCategories.forEach(t=>{
      const o=document.createElement('option'); o.value=t; o.textContent=t; ruleType.appendChild(o);
    });
  }
  updateSubtypeFilterOptions();
}

function updateSubtypeFilterOptions(){
  const filter = document.getElementById('filter-subtype');
  if(!filter) return;
  const curr = filter.value;
  filter.innerHTML = '<option value="">All sub types</option><option value="__blank">Blank</option>';
  financeData.budgets.forEach(b=>{
    const o=document.createElement('option'); o.value=b.name; o.textContent=b.name; filter.appendChild(o);
  });
  filter.value = curr;
}

function updateRulePotOptions(){
  const sel = document.getElementById('rule-pot');
  if(sel){
    sel.innerHTML = '<option value="">Select pot</option>';
    financeData.pots.forEach(p=>{ const o=document.createElement('option'); o.value=p.id; o.textContent=p.name; sel.appendChild(o); });
  }
}

function currentBudgetVersion(sub){
  if(!sub.versions || !sub.versions.length) return null;
  const today=new Date();
  const sorted=sub.versions.slice().sort((a,b)=>parseDate(a.start)-parseDate(b.start));
  let curr=sorted.find(v=>today>=parseDate(v.start)&&today<=parseDate(v.end));
  if(!curr) curr=sorted[sorted.length-1];
  return curr;
}

function budgetVersionForMonth(sub, targetMonth){
  if(!sub.versions || !sub.versions.length) return null;
  if(!targetMonth || targetMonth === 'current') return currentBudgetVersion(sub);
  
  // Parse target month (format: "MM YYYY")
  const [month, year] = targetMonth.split(' ');
  const targetDate = new Date(parseInt(year), parseInt(month) - 1, 15); // Use middle of month
  
  const sorted=sub.versions.slice().sort((a,b)=>parseDate(a.start)-parseDate(b.start));
  let curr=sorted.find(v=>targetDate>=parseDate(v.start)&&targetDate<=parseDate(v.end));
  if(!curr) {
    // If no exact match, find the latest version before this date
    curr = sorted.filter(v=>parseDate(v.start)<=targetDate).pop();
  }
  if(!curr) curr=sorted[0]; // Fallback to first version
  return curr;
}

function monthToDate(month){
  const [m,y]=month.split(' ');
  return new Date(parseInt(y,10),parseInt(m,10)-1,1);
}

function monthsBetween(startDate,endDate){
  const res=[];
  const d=new Date(startDate);
  const end=new Date(endDate);
  while(d<=end){
    res.push(`${String(d.getMonth()+1).padStart(2,'0')} ${d.getFullYear()}`);
    d.setMonth(d.getMonth()+1);
  }
  return res;
}

function baseAmountForMonth(sub, month){
  if(!sub.versions || !sub.versions.length) return 0;
  const mStart=monthToDate(month);
  const mEnd=new Date(mStart.getFullYear(), mStart.getMonth()+1, 0);
  let amt=0;
  sub.versions.forEach(v=>{
    const s=parseDate(v.start);
    const e=parseDate(v.end);
    if(e>=mStart && s<=mEnd){
      const interval=parseInt(v.interval||1,10);
      const mode=v.mode||'within';
      const diffMonths=(mStart.getFullYear()-s.getFullYear())*12 + (mStart.getMonth()-s.getMonth());
      if(interval<=1){
        amt+=parseFloat(v.amount||0);
      } else if(mode==='within'){
        if(diffMonths%interval===0) amt+=parseFloat(v.amount||0);
      } else {
        amt+=parseFloat(v.amount||0)/interval;
      }
    }
  });
  return amt;
}

function budgetAppliesToMonth(sub, month){
  if(!sub.versions || !sub.versions.length) return false;
  const mStart=monthToDate(month);
  const mEnd=new Date(mStart.getFullYear(), mStart.getMonth()+1, 0);
  return sub.versions.some(v=>{
    const s=parseDate(v.start);
    const e=parseDate(v.end);
    if(e<mStart || s>mEnd) return false;
    const interval=parseInt(v.interval||1,10);
    const diffMonths=(mStart.getFullYear()-s.getFullYear())*12 + (mStart.getMonth()-s.getMonth());
    if(interval<=1) return true;
    return (v.mode||'within')==='within' ? diffMonths%interval===0 : true;
  });
}

function extraForMonth(sub, month){
  return (sub.extras||[]).filter(e=>e.month===month).reduce((s,e)=>s+parseFloat(e.amount||0),0);
}

function amountForMonth(sub, month){
  return baseAmountForMonth(sub, month) + extraForMonth(sub, month);
}

function openBudgetModal(sub, editIndex=-1, isNew=false){
  sub.versions = sub.versions || [];
  normalizeVersions(sub);
  const modal=document.getElementById('budget-modal');
  if(!modal) return;
  const monthStart=new Date();
  monthStart.setDate(1);
  const todayStr=monthStart.toISOString().slice(0,10);
  const farDate=new Date(monthStart);
  farDate.setFullYear(farDate.getFullYear()+100);
  const far=farDate.toISOString().slice(0,10);
  const curr=sub.versions.length?currentBudgetVersion(sub):null;
  const defaultVer={amount:0,start:todayStr,end:far,interval:1,mode:'within'};
  const v=editIndex>=0 && sub.versions[editIndex]? sub.versions[editIndex] : (curr || defaultVer);
  const allStart=sub.versions.length? sub.versions.reduce((m,x)=>parseDate(x.start)<m?parseDate(x.start):m,parseDate(sub.versions[0].start)) : parseDate(v.start);
  const allEnd=sub.versions.length? sub.versions.reduce((m,x)=>parseDate(x.end)>m?parseDate(x.end):m,parseDate(sub.versions[0].end)) : parseDate(v.end);
  const monthOpts=monthsBetween(allStart,allEnd);
  modal.innerHTML=`<form id="budget-edit-form">
    <label>Category <select id="edit-type"></select></label>
    <label>Name <input type="text" id="edit-name" value="${sub.name||''}" ${isNew?'':'disabled'}></label>
    <label>Description <textarea id="edit-desc">${sub.desc||''}</textarea></label>
    <label>Amount <input type="number" id="edit-amount" value="${v.amount}"></label>
    <label>Start <input type="date" id="edit-start" value="${v.start}"></label>
    <label>End <input type="date" id="edit-end" value="${v.end}"></label>
    <label>Interval (months) <input type="number" id="edit-interval" value="${v.interval||1}"></label>
    <label>Mode <select id="edit-mode"><option value="within">Within Month</option><option value="throughout">Throughout</option></select></label>
  <label style="display:inline-flex;align-items:center;gap:6px;"><input type="checkbox" id="edit-fixed" ${sub.fixed?'checked':''}> Fixed (treat as spent in current/future)</label>
    <button type="submit">Save</button>
    <button type="button" id="close-budget-modal">Close</button>
    ${(editIndex>=0 && !isNew) ? '<button type="button" id="cancel-edit">Cancel</button>' : ''}
  </form>
  <h4>History</h4>
  <table><thead><tr><th>Ver</th><th>Start</th><th>End</th><th>Amount</th><th>Interval</th><th>Mode</th><th></th></tr></thead><tbody></tbody></table>
  <h4>Extras</h4>
  <form id="extra-form">
    <input type="number" id="extra-amount" placeholder="Amount">
    <select id="extra-months" multiple size="5"></select>
    <button type="submit">Add Extra</button>
  </form>
  <table id="extra-table"><thead><tr><th>Month</th><th>Amount</th><th></th></tr></thead><tbody></tbody></table>`;
  const typeSel=modal.querySelector('#edit-type');
  financeData.budgetCategories.forEach(cat=>{ const o=document.createElement('option'); o.value=cat; o.textContent=cat; typeSel.appendChild(o); });
  typeSel.value=sub.type||'';
  const modeSel=modal.querySelector('#edit-mode'); modeSel.value=v.mode||'within';
  if(editIndex===-1){
    if(v.start===todayStr) modal.querySelector('#edit-start').insertAdjacentHTML('afterend','<small>(default today)</small>');
    if(v.end===far) modal.querySelector('#edit-end').insertAdjacentHTML('afterend','<small>(default 100y)</small>');
  }
  const histTbody=modal.querySelector('table tbody');
  (sub.versions||[]).slice().sort((a,b)=>parseDate(b.start)-parseDate(a.start)).forEach(ver=>{
    const idx=sub.versions.indexOf(ver);
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${ver.version||idx+1}</td><td>${ver.start}</td><td>${ver.end}</td><td>${ver.amount}</td><td>${ver.interval||1}</td><td>${ver.mode||'within'}</td><td><button class="edit-ver" data-idx="${idx}">Edit</button><button class="del-ver" data-idx="${idx}">Delete</button></td>`;
    if(ver===curr) tr.style.background='lightgreen';
    histTbody.appendChild(tr);
  });
  histTbody.querySelectorAll('.edit-ver').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const idx=parseInt(btn.dataset.idx);
      openBudgetModal(sub, idx);
    });
  });
  histTbody.querySelectorAll('.del-ver').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const idx=parseInt(btn.dataset.idx);
      if(confirm('Delete this version?')){
        sub.versions.splice(idx,1);
        normalizeVersions(sub);
        saveFinance();
        renderBudgets();
        renderOverview();
        openBudgetModal(sub);
      }
    });
  });
  const extraSel=modal.querySelector('#extra-months');
  monthOpts.forEach(m=>{ const o=document.createElement('option'); o.value=m; o.textContent=m; extraSel.appendChild(o); });
  const extraTbody=modal.querySelector('#extra-table tbody');
  (sub.extras||[]).forEach((ex,i)=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${ex.month}</td><td>${ex.amount}</td><td><button class="edit-extra" data-idx="${i}">Edit</button><button class="del-extra" data-idx="${i}">Delete</button></td>`;
    extraTbody.appendChild(tr);
  });
  extraTbody.querySelectorAll('.del-extra').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const idx=parseInt(btn.dataset.idx);
      sub.extras.splice(idx,1);
      saveFinance();
      renderOverview();
      openBudgetModal(sub);
    });
  });
  extraTbody.querySelectorAll('.edit-extra').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const idx=parseInt(btn.dataset.idx);
      const ex=sub.extras[idx];
      const amt=parseFloat(prompt('Amount', ex.amount));
      if(isNaN(amt)) return;
      const month=prompt('Month (MM YYYY)', ex.month);
      if(!monthOpts.includes(month)) { alert('Invalid month'); return; }
      ex.amount=amt; ex.month=month;
      saveFinance();
      renderOverview();
      openBudgetModal(sub);
    });
  });
  modal.querySelector('#extra-form').addEventListener('submit', e=>{
    e.preventDefault();
    const amt=parseFloat(modal.querySelector('#extra-amount').value);
    const months=Array.from(extraSel.selectedOptions).map(o=>o.value);
    if(isNaN(amt) || !months.length) return;
    months.forEach(m=>sub.extras.push({month:m,amount:amt}));
    modal.querySelector('#extra-amount').value='';
    extraSel.selectedIndex=-1;
    saveFinance();
    renderOverview();
    openBudgetModal(sub);
  });
  modal.style.display='block';
  modal.querySelector('#close-budget-modal').addEventListener('click',()=>{ modal.style.display='none'; });
  if(editIndex>=0 && !isNew){
    modal.querySelector('#cancel-edit').addEventListener('click',()=>openBudgetModal(sub));
  }
  modal.querySelector('#budget-edit-form').addEventListener('submit',e=>{
    e.preventDefault();
    const newType=typeSel.value;
    const name=modal.querySelector('#edit-name').value.trim();
    const desc=modal.querySelector('#edit-desc').value.trim();
    const amount=parseFloat(modal.querySelector('#edit-amount').value);
    const start=modal.querySelector('#edit-start').value||todayStr;
    const end=modal.querySelector('#edit-end').value||far;
  const isFixed = !!modal.querySelector('#edit-fixed').checked;
    if(parseDate(end)<parseDate(start)){
      alert('End date must be after start date');
      return;
    }
    const interval=parseInt(modal.querySelector('#edit-interval').value)||1;
    const mode=modal.querySelector('#edit-mode').value;
    if(isNew){
      if(!newType || !name) return;
      sub.type=newType;
      sub.name=name;
      sub.desc=desc;
      sub.archived=false;
  sub.fixed=isFixed;
      sub.versions=[{amount,start,end,interval,mode}];
      sub.extras=[];
      financeData.budgets.push(sub);
      financeData.nextBudgetId++;
    } else {
      const same=v.amount==amount && v.start==start && v.end==end && v.interval==interval && v.mode==mode;
      if(editIndex>=0){
        sub.versions[editIndex]={amount,start,end,interval,mode};
      } else if(!same){
        sub.versions.push({amount,start,end,interval,mode});
      }
      sub.desc=desc;
  sub.fixed=isFixed;
      if(newType!==sub.type){
        financeData.transactions.forEach(t=>{ if(t.type===sub.type && t.subType===sub.name){ t.type=newType; } });
        financeData.rules.forEach(r=>{ if(r.type===sub.type && r.subType===sub.name){ r.type=newType; } });
        sub.type=newType;
      }
    }
    normalizeVersions(sub);
    const currV=currentBudgetVersion(sub);
    if(currV){
      sub.amount=currV.amount;
      sub.date=currV.start;
    }
    modal.style.display='none';
    saveFinance();
    renderBudgets();
    renderOverview();
    renderTransactions();
    renderRules();
    renderSettingsSections();
  });
}

function renderSettingsSections(){
  console.log('renderSettingsSections called');
  // Only render budget category settings in the budgets tab
  const budgetContainer = document.getElementById('budget-settings');
  console.log('budgetContainer found:', !!budgetContainer);
  if(budgetContainer) {
    budgetContainer.innerHTML = `
      <style>
        .budget-settings-container {
          background: #f8f9fa;
          border-radius: 8px;
          padding: 20px;
          margin: 10px 0;
        }
        .budget-form {
          background: white;
          padding: 15px;
          border-radius: 6px;
          margin-bottom: 20px;
          border: 1px solid #ddd;
        }
        .budget-form h4 {
          margin: 0 0 15px 0;
          color: #495057;
          font-size: 16px;
        }
        .budget-form input, .budget-form select, .budget-form button {
          margin: 5px;
          padding: 8px 12px;
          border: 1px solid #ced4da;
          border-radius: 4px;
        }
        .budget-form button {
          background: #007bff;
          color: white;
          border: none;
          cursor: pointer;
          font-weight: 500;
        }
        .budget-form button:hover {
          background: #0056b3;
        }
        .budget-category-card {
          background: white;
          border: 1px solid #ddd;
          border-radius: 6px;
          margin-bottom: 15px;
          overflow: hidden;
        }
        .budget-category-header {
          background: #e9ecef;
          padding: 12px 15px;
          border-bottom: 1px solid #ddd;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .budget-category-title {
          font-weight: 600;
          color: #495057;
          margin: 0;
        }
        .budget-category-actions button {
          margin-left: 8px;
          padding: 4px 8px;
          border: none;
          border-radius: 3px;
          cursor: pointer;
          font-size: 12px;
        }
        .btn-delete {
          background: #dc3545;
          color: white;
        }
        .btn-delete:hover {
          background: #c82333;
        }
        .budget-sub-list {
          padding: 0;
          margin: 0;
          list-style: none;
        }
        .budget-sub-item {
          padding: 10px 15px;
          border-bottom: 1px solid #f0f0f0;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .budget-sub-item:last-child {
          border-bottom: none;
        }
        .budget-sub-info {
          flex: 1;
        }
        .budget-sub-name {
          font-weight: 500;
          color: #495057;
        }
        .budget-sub-desc {
          font-size: 12px;
          color: #6c757d;
          margin-top: 2px;
        }
        .budget-sub-actions button {
          margin-left: 6px;
          padding: 3px 8px;
          border: none;
          border-radius: 3px;
          cursor: pointer;
          font-size: 11px;
        }
        .btn-edit {
          background: #28a745;
          color: white;
        }
        .btn-edit:hover {
          background: #218838;
        }
      </style>
      <div class="budget-settings-container">
        <div class="budget-form">
          <h4>Add New Category</h4>
          <form class="type-form">
            <input type="text" class="new-type-name" placeholder="Category Name" required>
            <input type="date" class="new-type-start" title="Start Date">
            <label style="display:inline-flex;align-items:center;gap:6px;"><input type="checkbox" class="new-type-fixed"> Fixed</label>
            <button type="submit">Add Category</button>
          </form>
        </div>
        
        <div class="budget-form">
          <h4>Add Sub-Budget</h4>
          <form class="subtype-form">
            <select class="subtype-type" required>
              <option value="">Select Category</option>
            </select>
            <button type="button" class="add-subtype-btn">Add Sub-Budget</button>
          </form>
        </div>
        
        <div class="budget-categories-list"></div>
      </div>`;
    
    const typeForm = budgetContainer.querySelector('.type-form');
    typeForm.addEventListener('submit', e=>{
      e.preventDefault();
      const name = budgetContainer.querySelector('.new-type-name').value.trim();
      const start = budgetContainer.querySelector('.new-type-start').value || new Date().toISOString().slice(0,10);
      const fixed = !!budgetContainer.querySelector('.new-type-fixed').checked;
      if(!name || financeData.budgetCategories.includes(name)) return;
      financeData.budgetCategories.push(name);
      financeData.categoryStarts[name]=start;
      financeData.categoryFixed[name]=fixed;
      budgetContainer.querySelector('.new-type-name').value='';
      budgetContainer.querySelector('.new-type-start').value='';
      budgetContainer.querySelector('.new-type-fixed').checked=false;
      saveFinance();
      updateTypeOptions();
      renderBudgets();
      renderOverview();
      renderSettingsSections();
    });
    
    const subtypeForm = budgetContainer.querySelector('.subtype-form');
    const typeSelect = budgetContainer.querySelector('.subtype-type');
    function fillTypes(){
      typeSelect.innerHTML = '<option value="">Select Category</option>';
      financeData.budgetCategories.forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; typeSelect.appendChild(o); });
    }
    fillTypes();
    subtypeForm.querySelector('.add-subtype-btn').addEventListener('click',()=>{
      const type = typeSelect.value;
      if(!type) return;
      const nb={id:financeData.nextBudgetId, type, name:'', archived:false, versions:[], extras:[], desc:''};
      openBudgetModal(nb, -1, true);
    });

    // Render categories and sub-budgets in nice cards
    const categoriesList = budgetContainer.querySelector('.budget-categories-list');
    console.log('categoriesList found:', !!categoriesList);
    console.log('financeData.budgetCategories:', financeData.budgetCategories);
    financeData.budgetCategories.forEach(cat=>{
      const categoryCard = document.createElement('div');
      categoryCard.className = 'budget-category-card';
      
      const categoryHeader = document.createElement('div');
      categoryHeader.className = 'budget-category-header';
      
      const categoryTitle = document.createElement('h5');
      categoryTitle.className = 'budget-category-title';
      const start = financeData.categoryStarts[cat] || '';
  categoryTitle.textContent = start ? `${cat} (${start})` : cat;
      
  const categoryActions = document.createElement('div');
      categoryActions.className = 'budget-category-actions';
  // Fixed checkbox for category
  const fixedWrap = document.createElement('label');
  fixedWrap.style.display='inline-flex'; fixedWrap.style.alignItems='center'; fixedWrap.style.gap='6px';
  const catFixedCb = document.createElement('input'); catFixedCb.type='checkbox'; catFixedCb.checked=!!financeData.categoryFixed[cat];
  fixedWrap.appendChild(catFixedCb); fixedWrap.appendChild(document.createTextNode('Fixed'));
  catFixedCb.addEventListener('change',()=>{ financeData.categoryFixed[cat]=!!catFixedCb.checked; saveFinance(); renderSettingsSections(); });
  categoryActions.appendChild(fixedWrap);
      
      if(!cat.startsWith('Other')){
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn-delete';
        deleteBtn.textContent = 'Delete Category';
        deleteBtn.addEventListener('click',()=>{
          if(confirm('Delete category and all its sub budgets? This will remove related types from transactions.')){
            financeData.budgets = financeData.budgets.filter(b=>b.type!==cat);
            financeData.transactions.forEach(t=>{ if(t.type===cat){ t.type=''; t.subType=''; } });
            financeData.rules = financeData.rules.filter(r=>r.type!==cat);
            financeData.budgetCategories = financeData.budgetCategories.filter(c=>c!==cat);
            delete financeData.categoryStarts[cat];
            delete financeData.categoryFixed[cat];
            saveFinance();
            renderBudgets();
            renderOverview();
            renderTransactions();
            renderRules();
            updateTypeOptions();
            renderSettingsSections();
          }
        });
        categoryActions.appendChild(deleteBtn);
      }
      
      categoryHeader.appendChild(categoryTitle);
      categoryHeader.appendChild(categoryActions);
      categoryCard.appendChild(categoryHeader);
      
      // Add sub-budgets
      const subs = financeData.budgets.filter(b=>b.type===cat);
    if(subs.length) {
        const subList = document.createElement('ul');
        subList.className = 'budget-sub-list';
        
        subs.forEach(sub=>{
          const subItem = document.createElement('li');
          subItem.className = 'budget-sub-item';
          
          const subInfo = document.createElement('div');
          subInfo.className = 'budget-sub-info';
          
          const subName = document.createElement('div');
          subName.className = 'budget-sub-name';
          subName.textContent = sub.name;
          subInfo.appendChild(subName);
          
          if(sub.desc) {
            const subDesc = document.createElement('div');
            subDesc.className = 'budget-sub-desc';
            subDesc.textContent = sub.desc;
            subInfo.appendChild(subDesc);
          }
          
      const subActions = document.createElement('div');
          subActions.className = 'budget-sub-actions';

      // Fixed toggle for sub-budget
      const subFixedWrap = document.createElement('label');
      subFixedWrap.style.display='inline-flex'; subFixedWrap.style.alignItems='center'; subFixedWrap.style.gap='6px'; subFixedWrap.style.marginRight='8px';
      const subFixedCb = document.createElement('input'); subFixedCb.type='checkbox'; subFixedCb.checked=!!sub.fixed;
      subFixedWrap.appendChild(subFixedCb); subFixedWrap.appendChild(document.createTextNode('Fixed'));
      subFixedCb.addEventListener('change',()=>{ sub.fixed=!!subFixedCb.checked; saveFinance(); renderOverview(); });
      subActions.appendChild(subFixedWrap);
          
          const editBtn = document.createElement('button');
          editBtn.className = 'btn-edit';
          editBtn.textContent = 'Edit';
          editBtn.addEventListener('click',()=>openBudgetModal(sub));
          
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'btn-delete';
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click',()=>{
            if(confirm('Delete this sub budget? This will remove it from any transactions.')){
              financeData.budgets = financeData.budgets.filter(b=>!(b.type===sub.type && b.name===sub.name));
              financeData.transactions.forEach(t=>{ if(t.type===sub.type && t.subType===sub.name){ t.type=''; t.subType=''; } });
              financeData.rules = financeData.rules.filter(r=>!(r.type===sub.type && r.subType===sub.name));
              saveFinance();
              renderBudgets();
              renderOverview();
              renderTransactions();
              renderRules();
              renderSettingsSections();
            }
          });
          
          subActions.appendChild(editBtn);
          subActions.appendChild(deleteBtn);
          
          subItem.appendChild(subInfo);
          subItem.appendChild(subActions);
          subList.appendChild(subItem);
        });
        
        categoryCard.appendChild(subList);
      }
      
      categoriesList.appendChild(categoryCard);
    });
    
    // Handle uncategorized budgets
    const uncats = financeData.budgets.filter(b=>!b.type);
    if(uncats.length){
      const uncatCard = document.createElement('div');
      uncatCard.className = 'budget-category-card';
      
      const uncatHeader = document.createElement('div');
      uncatHeader.className = 'budget-category-header';
      
      const uncatTitle = document.createElement('h5');
      uncatTitle.className = 'budget-category-title';
      uncatTitle.textContent = 'Uncategorized';
      uncatHeader.appendChild(uncatTitle);
      uncatCard.appendChild(uncatHeader);
      
      const uncatList = document.createElement('ul');
      uncatList.className = 'budget-sub-list';
      
      uncats.forEach(sub=>{
        const uncatItem = document.createElement('li');
        uncatItem.className = 'budget-sub-item';
        
        const uncatInfo = document.createElement('div');
        uncatInfo.className = 'budget-sub-info';
        
        const uncatName = document.createElement('div');
        uncatName.className = 'budget-sub-name';
        uncatName.textContent = sub.name;
        uncatInfo.appendChild(uncatName);
        
        if(sub.desc) {
          const uncatDesc = document.createElement('div');
          uncatDesc.className = 'budget-sub-desc';
          uncatDesc.textContent = sub.desc;
          uncatInfo.appendChild(uncatDesc);
        }
        
        const uncatActions = document.createElement('div');
        uncatActions.className = 'budget-sub-actions';
        
        const editBtn = document.createElement('button');
        editBtn.className = 'btn-edit';
        editBtn.textContent = 'Edit';
        editBtn.addEventListener('click',()=>openBudgetModal(sub));
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn-delete';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click',()=>{
          if(confirm('Delete this sub budget? This will remove it from any transactions.')){
            financeData.budgets = financeData.budgets.filter(b=>!(b.type===sub.type && b.name===sub.name));
            financeData.transactions.forEach(t=>{ if(t.type===sub.type && t.subType===sub.name){ t.type=''; t.subType=''; } });
            financeData.rules = financeData.rules.filter(r=>!(r.type===sub.type && r.subType===sub.name));
            saveFinance();
            renderBudgets();
            renderOverview();
            renderTransactions();
            renderRules();
            renderSettingsSections();
          }
        });
        
        uncatActions.appendChild(editBtn);
        uncatActions.appendChild(deleteBtn);
        
        uncatItem.appendChild(uncatInfo);
        uncatItem.appendChild(uncatActions);
        uncatList.appendChild(uncatItem);
      });
      
      uncatCard.appendChild(uncatList);
      categoriesList.appendChild(uncatCard);
    }
    
    // Add Non-Duplicate Groups management
    const nonDupSection = document.createElement('div');
    nonDupSection.style.marginTop = '30px';
    nonDupSection.innerHTML = `
      <h4 style="color: #495057; margin-bottom: 15px;">Non-Duplicate Groups</h4>
      <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
        Transaction groups you've marked as "Keep All" - these won't be flagged as duplicates anymore.
      </p>
      <div id="non-duplicate-list"></div>
    `;
    budgetContainer.appendChild(nonDupSection);
    
    const nonDupList = document.getElementById('non-duplicate-list');
    if(financeData.nonDuplicateGroups.length === 0) {
      nonDupList.innerHTML = '<p style="color: #999; font-style: italic;">No non-duplicate groups defined.</p>';
    } else {
      financeData.nonDuplicateGroups.forEach((key, index) => {
        const [date, description, amount, account] = key.split('|');
        const groupDiv = document.createElement('div');
        groupDiv.style.cssText = 'background: white; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;';
        
        const infoDiv = document.createElement('div');
        infoDiv.innerHTML = `
          <strong>${description}</strong><br>
          <small style="color: #666;">${formatDateDisplay(date)} | ${amount} | ${account}</small>
        `;
        
        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.style.cssText = 'background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;';
        removeBtn.addEventListener('click', () => {
          if(confirm('Remove this group from non-duplicate list? These transactions may be flagged as duplicates again.')) {
            financeData.nonDuplicateGroups.splice(index, 1);
            checkDuplicates();
            saveFinance();
            renderTransactions();
            renderSettingsSections();
          }
        });
        
        groupDiv.appendChild(infoDiv);
        groupDiv.appendChild(removeBtn);
        nonDupList.appendChild(groupDiv);
      });
    }
  }
}

function renderCodeSettings(){
  // Only render autofill rules in the code tab
  const codeContainer = document.getElementById('code-settings');
  if(codeContainer) {
    codeContainer.innerHTML = `
      <h3>Autofill Rules</h3>
      <p>Create rules to automatically categorize transactions based on description, account, or amount.</p>
      
      <div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 5px;">
        <h4>Apply Rules</h4>
        <button type="button" id="apply-uncoded" style="margin-right: 1rem; padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">Apply to Uncoded Only</button>
        <button type="button" id="apply-all" style="padding: 0.5rem 1rem; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">Apply to All (Override Existing)</button>
        <div style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
          <strong>Uncoded Only:</strong> Apply rules only to transactions without categories<br>
          <strong>Apply to All:</strong> Apply rules to all matching transactions, overriding existing categories
        </div>
      </div>

      <form id="rule-form">
        <div class="rule-sections">
          <div class="rule-section">
            <h4 class="rule-section-header input-header">üì• Match Criteria (Input)</h4>
            <p class="rule-section-desc">Specify which transactions this rule should match:</p>
            <div class="rule-inputs">
              <div>
                <label>Description Contains:</label>
                <input type="text" id="rule-desc" placeholder="Text to match in description">
              </div>
              <div>
                <label>Account:</label>
                <select id="rule-account">
                  <option value="">Any account</option>
                </select>
              </div>
              <div>
                <label>Amount:</label>
                <input type="number" id="rule-amount" placeholder="Exact amount" step="0.01">
              </div>
            </div>
          </div>
          
          <div class="rule-section">
            <h4 class="rule-section-header output-header">üì§ Apply Actions (Output)</h4>
            <p class="rule-section-desc">What to automatically set when a transaction matches:</p>
            <div class="rule-inputs">
              <div>
                <label>Category: <span class="required">*</span></label>
                <div id="rule-category-container"></div>
              </div>
              <div>
                <label>Pot:</label>
                <select id="rule-pot"><option value="">Select pot</option></select>
              </div>
              <div>
                <label>Notes:</label>
                <input type="text" id="rule-notes" placeholder="Set note text">
              </div>
            </div>
          </div>
        </div>
        <button type="submit">Add Rule</button>
      </form>
      <table id="rule-table">
        <thead><tr><th colspan="3">Match Criteria</th><th colspan="3">Apply Actions</th><th>Action</th></tr></thead>
        <thead><tr><th>Description</th><th>Account</th><th>Amount</th><th>Category</th><th>Pot</th><th>Notes</th><th></th></tr></thead>
        <tbody></tbody>
      </table>`;
    
    // Create the category selector button for rules
    let ruleType = '';
    let ruleSubType = '';
    const ruleCategorySelector = createCategoryModalSelector(
      '', '', 
      (newType, newSubType) => {
        ruleType = newType;
        ruleSubType = newSubType;
      }
    );
    document.getElementById('rule-category-container').appendChild(ruleCategorySelector);
    
    // Set up the rule form event listener
    const ruleForm = codeContainer.querySelector('#rule-form');
    ruleForm.addEventListener('submit', e=>{
      e.preventDefault();
      const match = document.getElementById('rule-desc').value.trim();
      const account = document.getElementById('rule-account').value;
      const amount = document.getElementById('rule-amount').value;
      const potId = document.getElementById('rule-pot').value;
      const notes = document.getElementById('rule-notes').value.trim();
      
      if(!ruleType) return;
      
      const rule = {
        id: Date.now(),
        match: match || null,
        account: account || null,
        amount: amount ? parseFloat(amount) : null,
        type: ruleType,
        subType: ruleSubType || null,
        potId: potId ? parseInt(potId) : null,
        notes: notes || null
      };
      
      financeData.rules.push(rule);
      
      // Reset form
      ruleType = '';
      ruleSubType = '';
      ruleCategorySelector.updateValues('', '');
      
      saveFinance();
      renderCodeSettings();
      renderTransactions();
    });
    
    // Add event listeners for the new buttons
    document.getElementById('apply-uncoded').addEventListener('click', () => {
      applyRulesToTransactions(false); // false = uncoded only
    });
    
    document.getElementById('apply-all').addEventListener('click', () => {
      if(confirm('This will override existing categories for all matching transactions. Are you sure?')) {
        applyRulesToTransactions(true); // true = apply to all
      }
    });
    
    // Populate the dropdowns
    updateRuleOptions();
    renderRules();
  }
}

function updateRuleOptions(){
  const accountSelect = document.getElementById('rule-account');
  const potSelect = document.getElementById('rule-pot');
  
  if(accountSelect) {
    accountSelect.innerHTML = '<option value="">Any account</option>';
    financeData.accounts.forEach(acc=>{
      const option = document.createElement('option');
      option.value = acc;
      option.textContent = acc;
      accountSelect.appendChild(option);
    });
  }
  
  if(potSelect) {
    potSelect.innerHTML = '<option value="">Select pot</option>';
    financeData.pots.forEach(pot=>{
      const option = document.createElement('option');
      option.value = pot.id;
      option.textContent = pot.name;
      potSelect.appendChild(option);
    });
  }
}

function renderUploadSettings(){
  // Only render upload settings in the settings tab
  const uploadContainer = document.getElementById('upload-settings');
  if(uploadContainer) {
    uploadContainer.innerHTML = `
      <h3>Upload Settings</h3>
      <p>Configure file upload and account management settings.</p>
      <!-- Add upload-specific content here -->`;
  }
}

function renderRules(){
  updateRulePotOptions();
  const tbody = document.querySelector('#rule-table tbody');
  if(!tbody) return;
  tbody.innerHTML='';
  financeData.rules.forEach(r=>{
    const tr=document.createElement('tr');
    const delBtn=document.createElement('button');
    delBtn.textContent='Delete';
    delBtn.style.backgroundColor = '#dc3545';
    delBtn.style.color = 'white';
    delBtn.style.border = 'none';
    delBtn.style.padding = '2px 6px';
    delBtn.style.borderRadius = '3px';
    delBtn.style.cursor = 'pointer';
    delBtn.addEventListener('click',()=>{
      financeData.rules=financeData.rules.filter(x=>x.id!==r.id);
      saveFinance();
      renderRules();
    });
    
    // Create apply buttons for this specific rule
    const applyUncodedBtn = document.createElement('button');
    applyUncodedBtn.textContent = 'Apply to Uncoded';
    applyUncodedBtn.style.backgroundColor = '#28a745';
    applyUncodedBtn.style.color = 'white';
    applyUncodedBtn.style.border = 'none';
    applyUncodedBtn.style.padding = '2px 6px';
    applyUncodedBtn.style.borderRadius = '3px';
    applyUncodedBtn.style.cursor = 'pointer';
    applyUncodedBtn.style.marginRight = '4px';
    applyUncodedBtn.addEventListener('click', () => {
      applySingleRule(r, false); // false = uncoded only
    });
    
    const applyAllBtn = document.createElement('button');
    applyAllBtn.textContent = 'Apply to All';
    applyAllBtn.style.backgroundColor = '#ffc107';
    applyAllBtn.style.color = 'black';
    applyAllBtn.style.border = 'none';
    applyAllBtn.style.padding = '2px 6px';
    applyAllBtn.style.borderRadius = '3px';
    applyAllBtn.style.cursor = 'pointer';
    applyAllBtn.style.marginRight = '4px';
    applyAllBtn.addEventListener('click', () => {
      if(confirm(`Apply this rule to ALL matching transactions (will override existing categories)?`)) {
        applySingleRule(r, true); // true = apply to all
      }
    });
    
    const pot = financeData.pots.find(p=>p.id===r.potId);
    const potName = pot ? pot.name : '';
    
    // Format category display
    let categoryDisplay = '';
    if(r.subType) {
      categoryDisplay = `${r.type} ‚Üí ${r.subType}`;
    } else if(r.type) {
      categoryDisplay = r.type;
    }
    
    tr.innerHTML=`<td>${r.match||''}</td><td>${r.account||''}</td><td>${r.amount!=null?r.amount:''}</td><td>${categoryDisplay}</td><td>${potName}</td><td>${r.notes||''}</td>`;
    const td=document.createElement('td'); 
    td.appendChild(applyUncodedBtn); 
    td.appendChild(applyAllBtn); 
    td.appendChild(delBtn); 
    tr.appendChild(td);
    tbody.appendChild(tr);
  });
  
  // Clear form fields
  document.getElementById('rule-desc').value='';
  document.getElementById('rule-account').value='';
  document.getElementById('rule-amount').value='';
  document.getElementById('rule-pot').value='';
  document.getElementById('rule-notes').value='';
  
  // Clear category selector if it exists
  const categoryContainer = document.getElementById('rule-category-container');
  if(categoryContainer && categoryContainer.firstChild && categoryContainer.firstChild.updateValues) {
    categoryContainer.firstChild.updateValues('', '');
  }
}

// Apply a single specific rule to transactions
function applySingleRule(rule, applyToAll = false) {
  let appliedCount = 0;
  const processedTransactions = [];
  const mode = applyToAll ? 'transactions' : 'uncoded transactions';
  
  financeData.transactions.forEach(tx => {
    // Skip if this is uncoded-only mode and transaction already has a type
    if (!applyToAll && tx.type) {
      return;
    }
    
    // Check if this transaction matches the rule
    let matches = false;
    
    if (rule.match && tx.description && tx.description.toLowerCase().includes(rule.match.toLowerCase())) {
      matches = true;
    } else if (rule.account && tx.accountName === rule.account) {
      matches = true;
    } else if (rule.amount != null && parseFloat(tx.amount) === rule.amount) {
      matches = true;
    } else if (!rule.match && !rule.account && rule.amount == null) {
      // If no criteria specified, this rule would match everything (probably shouldn't happen)
      return;
    }
    
    if (matches) {
      // Store old values for change tracking
      const oldType = tx.type;
      const oldSubType = tx.subType;
      const oldPotId = tx.potId;
      const oldNotes = tx.notes;
      
      // Apply the rule
      if (rule.type) {
        tx.type = rule.type;
        tx.subType = rule.subType || '';
      }
      
      if (rule.potId != null) {
        tx.potId = rule.potId;
      }
      
      if (rule.notes != null) {
        tx.notes = rule.notes;
      }
      
      tx.autofill = true;
      tx.confirmed = false;
      delete tx.multipleRules;
      
      // Track changes for reporting
      const categoryChanged = (oldType !== tx.type || oldSubType !== tx.subType);
      const potChanged = (oldPotId !== tx.potId);
      const notesChanged = (oldNotes !== tx.notes);
      
      if (categoryChanged || potChanged || notesChanged) {
        appliedCount++;
        let changeDescription = '';
        
        if (categoryChanged) {
          const oldCategory = oldType && oldSubType ? `${oldType} ‚Üí ${oldSubType}` : oldType || 'None';
          const newCategory = tx.subType ? `${tx.type} ‚Üí ${tx.subType}` : tx.type;
          changeDescription += `Category: ${oldCategory} ‚Üí ${newCategory}`;
        }
        
        if (potChanged) {
          const oldPotName = oldPotId ? (financeData.pots.find(p => p.id === oldPotId)?.name || 'Unknown') : 'None';
          const newPotName = tx.potId ? (financeData.pots.find(p => p.id === tx.potId)?.name || 'Unknown') : 'None';
          if (changeDescription) changeDescription += '; ';
          changeDescription += `Pot: ${oldPotName} ‚Üí ${newPotName}`;
        }
        
        if (notesChanged) {
          if (changeDescription) changeDescription += '; ';
          changeDescription += `Notes: "${oldNotes || 'None'}" ‚Üí "${tx.notes || 'None'}"`;
        }
        
        processedTransactions.push({
          description: tx.description,
          changes: changeDescription
        });
      }
    }
  });
  
  if (appliedCount > 0) {
    saveFinance();
    renderTransactions();
    
    const resultMessage = `Applied rule to ${appliedCount} ${mode}.`;
    let detailMessage = resultMessage + '\n\nSummary of changes:\n';
    processedTransactions.slice(0, 10).forEach(tx => {
      detailMessage += `‚Ä¢ ${tx.description}: ${tx.changes}\n`;
    });
    if (processedTransactions.length > 10) {
      detailMessage += `... and ${processedTransactions.length - 10} more.`;
    }
    alert(detailMessage);
  } else {
    alert(`No ${mode} matched this rule.`);
  }
}

// Apply rules to transactions with different modes
function applyRulesToTransactions(applyToAll = false) {
  let appliedCount = 0;
  let processedTransactions = [];
  
  financeData.transactions.forEach(tx => {
    // Skip if we're only applying to uncoded and this transaction already has a type
    if (!applyToAll && tx.type) {
      return;
    }
    
    // Clear existing autofill flags if applying to all
    if (applyToAll) {
      delete tx.autofill;
      delete tx.multipleRules;
    }
    
    const matches = [];
    financeData.rules.forEach(r => {
      if (r.match && (!tx.description || !tx.description.toLowerCase().includes(r.match.toLowerCase()))) return;
      if (r.account && tx.accountName !== r.account) return;
      if (r.amount != null && parseFloat(tx.amount) !== r.amount) return;
      matches.push(r);
    });
    
    if (matches.length === 1) {
      const rule = matches[0];
      const oldType = tx.type;
      const oldSubType = tx.subType;
      const oldPotId = tx.potId;
      const oldNotes = tx.notes;
      
      // Only update category if rule specifies one
      if (rule.type) {
        tx.type = rule.type;
        tx.subType = rule.subType || '';
      }
      
      // Only update pot if rule specifies one
      if (rule.potId != null) {
        tx.potId = rule.potId;
      }
      
      // Only update notes if rule specifies them
      if (rule.notes != null) {
        tx.notes = rule.notes;
      }
      
      tx.autofill = true;
      tx.confirmed = false;
      delete tx.multipleRules;
      
      // Track changes for reporting
      const categoryChanged = (oldType !== tx.type || oldSubType !== tx.subType);
      const potChanged = (oldPotId !== tx.potId);
      const notesChanged = (oldNotes !== tx.notes);
      
      if (categoryChanged || potChanged || notesChanged) {
        appliedCount++;
        let changeDescription = '';
        
        if (categoryChanged) {
          const oldCategory = oldType && oldSubType ? `${oldType} ‚Üí ${oldSubType}` : oldType || 'None';
          const newCategory = tx.subType ? `${tx.type} ‚Üí ${tx.subType}` : tx.type;
          changeDescription += `Category: ${oldCategory} ‚Üí ${newCategory}`;
        }
        
        if (potChanged) {
          const oldPotName = oldPotId ? (financeData.pots.find(p => p.id === oldPotId)?.name || 'Unknown') : 'None';
          const newPotName = tx.potId ? (financeData.pots.find(p => p.id === tx.potId)?.name || 'Unknown') : 'None';
          if (changeDescription) changeDescription += '; ';
          changeDescription += `Pot: ${oldPotName} ‚Üí ${newPotName}`;
        }
        
        if (notesChanged) {
          if (changeDescription) changeDescription += '; ';
          changeDescription += `Notes: "${oldNotes || 'None'}" ‚Üí "${tx.notes || 'None'}"`;
        }
        
        processedTransactions.push({
          description: tx.description,
          changes: changeDescription
        });
      }
    } else if (matches.length > 1) {
      tx.multipleRules = matches.map(m => m.id);
      tx.autofill = true;
      tx.confirmed = false;
      appliedCount++;
      processedTransactions.push({
        description: tx.description,
        oldCategory: tx.type && tx.subType ? `${tx.type} ‚Üí ${tx.subType}` : tx.type || 'None',
        newCategory: 'Multiple rules match'
      });
    }
  });
  
  // Save and refresh
  saveFinance();
  renderTransactions();
  
  // Show results
  const mode = applyToAll ? 'all transactions' : 'uncoded transactions';
  const resultMessage = `Applied rules to ${appliedCount} ${mode}.`;
  
  if (appliedCount > 0) {
    let detailMessage = resultMessage + '\n\nSummary of changes:\n';
    processedTransactions.slice(0, 10).forEach(tx => {
      detailMessage += `‚Ä¢ ${tx.description}: ${tx.changes || tx.oldCategory + ' ‚Üí ' + tx.newCategory}\n`;
    });
    if (processedTransactions.length > 10) {
      detailMessage += `... and ${processedTransactions.length - 10} more.`;
    }
    alert(detailMessage);
  } else {
    alert(`No ${mode} matched your rules.`);
  }
}

async function saveFinance(){
  recalcPots();
  checkDuplicates();
  await fetch('/api/finance-data', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(financeData) });
}

// Searchable dropdown component
function createSearchableDropdown(placeholder = '-- Select Category --') {
  const container = document.createElement('div');
  container.className = 'searchable-dropdown';
  
  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'searchable-dropdown-input';
  input.placeholder = 'Search categories...';
  input.autocomplete = 'off';
  
  const select = document.createElement('select');
  select.className = 'searchable-dropdown-select';
  select.size = 8; // Show multiple options at once
  
  let options = [];
  let selectedValue = '';
  
  // Build options array and populate select
  function buildOptions() {
    options = [];
    select.innerHTML = '';
    
    // Add blank option
    const blankOption = document.createElement('option');
    blankOption.value = '';
    blankOption.textContent = placeholder;
    select.appendChild(blankOption);
    options.push({
      value: '',
      text: placeholder,
      searchText: '',
      type: 'blank',
      element: blankOption
    });
    
    // Group subcategories by type
    const categoryGroups = {};
    financeData.budgetCategories.forEach(cat => {
      categoryGroups[cat] = financeData.budgets.filter(b => b.type === cat && !b.archived);
    });
    
    // Add categories and subcategories
    financeData.budgetCategories.forEach(category => {
      // Add main category
      const categoryOption = document.createElement('option');
      categoryOption.value = `category:${category}`;
      categoryOption.textContent = category;
      categoryOption.style.fontWeight = 'bold';
      categoryOption.style.backgroundColor = '#f8f9fa';
      select.appendChild(categoryOption);
      
      options.push({
        value: `category:${category}`,
        text: category,
        searchText: category.toLowerCase(),
        type: 'category',
        element: categoryOption
      });
      
      // Add subcategories
      const subcategories = categoryGroups[category];
      if(subcategories && subcategories.length > 0) {
        subcategories.forEach(sub => {
          const subOption = document.createElement('option');
          subOption.value = `subcategory:${category}:${sub.name}`;
          subOption.textContent = `  ‚Ü≥ ${sub.name}`;
          subOption.style.paddingLeft = '20px';
          subOption.style.color = '#666';
          subOption.setAttribute('data-category', category);
          subOption.setAttribute('data-subcategory', sub.name);
          select.appendChild(subOption);
          
          options.push({
            value: `subcategory:${category}:${sub.name}`,
            text: sub.name,
            searchText: `${category} ${sub.name}`.toLowerCase(),
            type: 'subcategory',
            category: category,
            element: subOption
          });
        });
      }
    });
  }
  
  // Filter options based on search
  function filterOptions(searchTerm = '') {
    const term = searchTerm.toLowerCase().trim();
    
    options.forEach(option => {
      if (!term || option.searchText.includes(term) || option.type === 'blank') {
        option.element.style.display = '';
      } else {
        option.element.style.display = 'none';
      }
    });
  }
  
  // Input event listeners
  input.addEventListener('input', (e) => {
    filterOptions(e.target.value);
  });
  
  // Select change listener
  select.addEventListener('change', () => {
    selectedValue = select.value;
    
    // Clear search when something is selected
    input.value = '';
    filterOptions(''); // Show all options again
    
    // Trigger change event
    const event = new CustomEvent('change', { detail: { value: selectedValue } });
    container.dispatchEvent(event);
  });
  
  // Clear search on focus
  input.addEventListener('focus', () => {
    buildOptions();
  });
  
  container.appendChild(input);
  container.appendChild(select);
  
  // Public methods
  container.getValue = () => selectedValue;
  container.setValue = (value) => {
    selectedValue = value;
    buildOptions();
    select.value = value;
    input.value = '';
    filterOptions('');
  };
  container.clear = () => {
    selectedValue = '';
    select.value = '';
    input.value = '';
    filterOptions('');
  };
  
  return container;
}

// Modal-based category selector for table rows
function createCategoryModalSelector(currentType = '', currentSubType = '', onSelect) {
  const button = document.createElement('button');
  button.className = 'category-select-button';
  button.type = 'button';
  
  function updateButtonText() {
    if (currentSubType) {
      button.textContent = `${currentType} ‚Üí ${currentSubType}`;
      button.title = `${currentType} ‚Üí ${currentSubType}`;
      button.classList.remove('empty');
    } else if (currentType) {
      button.textContent = currentType;
      button.title = currentType;
      button.classList.remove('empty');
    } else {
      button.textContent = 'Select category';
      button.title = 'Click to select category';
      button.classList.add('empty');
    }
  }
  
  updateButtonText();
  
  button.addEventListener('click', () => {
    showCategoryModal(currentType, currentSubType, (newType, newSubType) => {
      currentType = newType;
      currentSubType = newSubType;
      updateButtonText();
      if (onSelect) {
        onSelect(newType, newSubType);
      }
    });
  });
  
  // Public method to update values
  button.updateValues = (newType, newSubType) => {
    currentType = newType;
    currentSubType = newSubType;
    updateButtonText();
  };
  
  return button;
}

// Show category selection modal
function showCategoryModal(currentType, currentSubType, onSelect) {
  // Remove existing modal if any
  const existingModal = document.getElementById('category-modal');
  if (existingModal) {
    existingModal.remove();
  }
  
  // Create modal
  const modal = document.createElement('div');
  modal.id = 'category-modal';
  modal.className = 'category-modal';
  
  modal.innerHTML = `
    <div class="category-modal-content">
      <div class="category-modal-header">
        <h3>Select Category</h3>
        <button class="category-modal-close">&times;</button>
      </div>
      <div id="modal-category-container"></div>
      <div style="margin-top: 15px; text-align: right;">
        <button id="modal-cancel" style="margin-right: 10px; padding: 0.5rem 1rem; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">Cancel</button>
        <button id="modal-select" style="padding: 0.5rem 1rem; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">Select</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Create the searchable dropdown inside modal
  const dropdown = createSearchableDropdown('-- Select Category --');
  document.getElementById('modal-category-container').appendChild(dropdown);
  
  // Set current value
  if (currentSubType) {
    dropdown.setValue(`subcategory:${currentType}:${currentSubType}`);
  } else if (currentType) {
    dropdown.setValue(`category:${currentType}`);
  }
  
  // Event handlers
  const closeModal = () => {
    modal.remove();
  };
  
  modal.querySelector('.category-modal-close').addEventListener('click', closeModal);
  modal.querySelector('#modal-cancel').addEventListener('click', closeModal);
  
  modal.querySelector('#modal-select').addEventListener('click', () => {
    const selectedValue = dropdown.getValue();
    let newType = '';
    let newSubType = '';
    
    if (selectedValue.startsWith('category:')) {
      newType = selectedValue.substring(9);
    } else if (selectedValue.startsWith('subcategory:')) {
      const parts = selectedValue.substring(12).split(':');
      newType = parts[0];
      newSubType = parts[1];
    }
    
    onSelect(newType, newSubType);
    closeModal();
  });
  
  // Close on outside click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeModal();
    }
  });
  
  // Show modal
  modal.style.display = 'block';
  
  // Focus on search input
  setTimeout(() => {
    const searchInput = modal.querySelector('.searchable-dropdown-input');
    if (searchInput) {
      searchInput.focus();
    }
  }, 100);
}

document.getElementById('upload-form').addEventListener('submit', async e=>{
  e.preventDefault();
  const file = document.getElementById('file-input').files[0];
  if(!file) return;
  const accountType = document.getElementById('account-type').value;
  const accountName = document.getElementById('account-name').value.trim();
  if(accountName && !financeData.accounts.includes(accountName)){
    financeData.accounts.push(accountName);
  }
  parseFile(file, accountType, accountName);
});

function parseFile(file, accountType, accountName){
  const reader = new FileReader();
  const ext = file.name.split('.').pop().toLowerCase();
  reader.onload = async () => {
    let rows = [];
    if(ext === 'csv'){
      rows = Papa.parse(reader.result, { header:true }).data;
    } else {
      const wb = XLSX.read(reader.result, { type:'binary' });
      const sheet = wb.Sheets[wb.SheetNames[0]];
      rows = XLSX.utils.sheet_to_json(sheet);
    }
    rows.forEach(r=>{
      let dateRaw='';
      let description='';
      let amount='';
      if(accountType === 'Monzo'){
        dateRaw = r.Date || r.date;
        description = r.Description || r.Name || r.name || '';
        if(r['Money Out']) amount = -parseFloat(r['Money Out']);
        if(r['Money In']) amount = parseFloat(r['Money In']);
        if(r.Amount) amount = parseFloat(r.Amount);
      } else if(accountType === 'TSB') {
        dateRaw = r['Transaction date'] || r['Transaction Date'] || r.Date || r.date || '';
        description = r['Transaction description'] || r.Description || '';
        const debit = parseFloat(r['Debit Amount'] || r['Debit amount'] || r.Debit || r['Debit'] || '');
        const credit = parseFloat(r['Credit amount'] || r['Credit Amount'] || r.Credit || r['Credit'] || '');
        if(!Number.isNaN(debit) && debit) amount = -Math.abs(debit);
        else if(!Number.isNaN(credit) && credit) amount = Math.abs(credit);
      } else {
        const keys = Object.keys(r).slice(0,8);
        keys.forEach(k=>{
          const lower=k.toLowerCase();
          if(lower.includes('description')) description = r[k];
          if(lower === 'date' || lower.startsWith('date ')) dateRaw = r[k];
          if(lower.includes('amount')) amount = r[k];
        });
      }
      const parsedDate = parseDate(dateRaw);
      const date = Number.isNaN(parsedDate.getTime()) ? '' : parsedDate.toISOString().slice(0,10);
      const tx = {
        id: financeData.nextTransactionId++,
        date,
        description,
        amount: parseFloat(amount || 0),
        accountType,
        accountName,
        month: '',
        sourceFile: file.name,
        uploadedAt: new Date().toISOString(),
        notes: '',
        transfer: false,
        potId: null
      };
      assignMonth(tx);
      applyRules(tx);
      financeData.transactions.push(tx);
    });
    checkDuplicates();
    await saveFinance();
    updateAccountList();
    renderStartBalances();
    renderTransactions();
    populateOverviewMonths();
    populateBalanceMonths();
    renderOverview();
    renderBalance();
    showTab('code');
    document.getElementById('upload-msg').textContent = 'Uploaded '+rows.length+' rows.';
  };
  if(ext === 'csv') reader.readAsText(file); else reader.readAsBinaryString(file);
}

// Backup functionality
function initializeBackupSection() {
  // Initialize backup info if it doesn't exist
  if (!financeData.backupInfo) {
    financeData.backupInfo = { lastBackup: null };
  }
  
  // Update last backup display
  updateLastBackupDisplay();
  
  // Add event listener for backup button
  document.getElementById('backup-now-btn').addEventListener('click', createBackup);
}

function updateLastBackupDisplay() {
  const lastBackupElement = document.getElementById('last-backup-date');
  if (financeData.backupInfo && financeData.backupInfo.lastBackup) {
    const date = new Date(financeData.backupInfo.lastBackup);
    lastBackupElement.textContent = date.toLocaleString();
  } else {
    lastBackupElement.textContent = 'Never';
  }
}

async function createBackup() {
  const statusElement = document.getElementById('backup-status');
  const button = document.getElementById('backup-now-btn');
  
  try {
    // Disable button and show status
    button.disabled = true;
    statusElement.textContent = 'Creating backup...';
    statusElement.style.color = '#007bff';
    
    // Create timestamp for filename
    const now = new Date();
    const timestamp = now.toISOString().replace(/:/g, '-').split('.')[0] + 'Z';
    const filename = `financeData-${timestamp}.json`;
    
    // Create backup data (copy of current financeData)
    const backupData = JSON.parse(JSON.stringify(financeData));
    
    // Make request to save backup
    const response = await fetch('/save-backup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        filename: filename,
        data: backupData
      })
    });
    
    if (response.ok) {
      // Update last backup time
      financeData.backupInfo.lastBackup = now.toISOString();
      
      // Save the updated financeData (with new lastBackup time)
      await saveFinance();
      
      // Update display
      updateLastBackupDisplay();
      
      // Show success message
      statusElement.textContent = `‚úÖ Backup created: ${filename}`;
      statusElement.style.color = '#28a745';
      
      // Clear status after 3 seconds
      setTimeout(() => {
        statusElement.textContent = '';
      }, 3000);
      
    } else {
      throw new Error('Failed to create backup');
    }
    
  } catch (error) {
    console.error('Backup failed:', error);
    statusElement.textContent = '‚ùå Backup failed!';
    statusElement.style.color = '#dc3545';
    
    // Clear error message after 5 seconds
    setTimeout(() => {
      statusElement.textContent = '';
    }, 5000);
  } finally {
    // Re-enable button
    button.disabled = false;
  }
}

window.addEventListener('DOMContentLoaded', () => {
  loadFinance();
  initializeBackupSection();
  document.getElementById('tab-settings').addEventListener('click', () => showTab('settings'));
  document.getElementById('tab-code').addEventListener('click', () => showTab('code'));
  document.getElementById('tab-budgets').addEventListener('click', () => showTab('budgets'));
  document.getElementById('tab-pots').addEventListener('click', () => { resetPotForm(); showTab('pots'); });
  // Split pot: toggle and add sub-pots in create form
  const splitCb=document.getElementById('pot-split');
  const subWrap=document.getElementById('subpot-container');
  const subList=document.getElementById('subpot-list');
  const addBtn=document.getElementById('add-subpot');
  if(splitCb){
    splitCb.addEventListener('change',()=>{
      subWrap.style.display=splitCb.checked?'block':'none';
      if(splitCb.checked && subList.children.length===0){ addSubpotRow(subList); }
    });
  }
  if(addBtn){ addBtn.addEventListener('click',()=>addSubpotRow(subList)); }
});
document.getElementById('add-account').addEventListener('click', () => {
  const name = document.getElementById('new-account').value.trim();
  if(!name || financeData.accounts.includes(name)) return;
  financeData.accounts.push(name);
  document.getElementById('new-account').value='';
  updateAccountList();
  renderStartBalances();
  saveFinance();
});

document.getElementById('filter-uncoded').addEventListener('change', renderTransactions);
document.getElementById('toggle-file').addEventListener('change', renderTransactions);

document.getElementById('apply-filters').addEventListener('click', () => {
  renderTransactions();
});

document.querySelectorAll('#tx-table thead .sort-btn').forEach(btn=>{
  btn.addEventListener('click', (e)=>{
    const field = btn.dataset.field;
    const isCtrlClick = e.ctrlKey || e.metaKey; // Support both Ctrl (Windows/Linux) and Cmd (Mac)
    
    if(!isCtrlClick) {
      // Normal click - replace all sort criteria with this field
      const existingIndex = txSortCriteria.findIndex(s => s.field === field);
      if(existingIndex === 0 && txSortCriteria.length === 1) {
        // Toggle direction if clicking the same primary sort
        txSortCriteria[0].dir *= -1;
      } else {
        // Set as new primary sort
        txSortCriteria = [{field, dir: 1}];
      }
    } else {
      // Ctrl+click - add/modify secondary sort criteria
      const existingIndex = txSortCriteria.findIndex(s => s.field === field);
      if(existingIndex !== -1) {
        // Toggle direction if already sorting by this field
        txSortCriteria[existingIndex].dir *= -1;
      } else {
        // Add as new sort criteria
        txSortCriteria.push({field, dir: 1});
      }
    }
    
    renderTransactions();
  });
});

document.getElementById('clear-sort').addEventListener('click', ()=>{
  txSortCriteria = [];
  renderTransactions();
});

document.getElementById('pot-form').addEventListener('submit', e=>{
  e.preventDefault();
  const kind=document.getElementById('pot-kind').value;
  const name=document.getElementById('pot-name').value.trim();
  const account=document.getElementById('pot-account').value;
  const desc=document.getElementById('pot-desc').value.trim();
  const start=document.getElementById('pot-start').value;
  const end=document.getElementById('pot-end').value;
  const goalVal=parseFloat(document.getElementById('pot-goal').value);
  const targetVal=parseFloat(document.getElementById('pot-target').value);
  const starting=parseFloat(document.getElementById('pot-starting').value)||0;
  const isSplit = document.getElementById('pot-split').checked;
  const subpotRows = Array.from(document.querySelectorAll('.subpot-row')).map(row=>{
    return {
      id: Date.now().toString() + Math.random().toString(16).slice(2),
      label: row.querySelector('.subpot-label').value.trim(),
      goalAmount: (v=>isNaN(v)?null:v)(parseFloat(row.querySelector('.subpot-goal').value)),
      assignedAmount: parseFloat(row.querySelector('.subpot-start').value||0) || 0
    };
  }).filter(sp=>sp.label);
  const pot={
    id:editingPotIndex!==null?financeData.pots[editingPotIndex].id:financeData.nextPotId++,
    kind,name,account,desc,start,end,
    goal:isNaN(goalVal)?null:goalVal,
    target:isNaN(targetVal)?null:targetVal,
    startAmount:starting,
    isSplit: !!isSplit,
    subPots: isSplit ? subpotRows : []
  };
  if(editingPotIndex!==null){
    financeData.pots[editingPotIndex]=pot;
  } else {
    financeData.pots.push(pot);
  }
  saveFinance();
  renderPots();
  renderTransactions();
  resetPotForm();
});

document.getElementById('pot-view-form').addEventListener('submit', e=>{
  e.preventDefault();
  const kind=document.getElementById('view-pot-kind').value;
  const name=document.getElementById('view-pot-name').value.trim();
  const account=document.getElementById('view-pot-account').value;
  const desc=document.getElementById('view-pot-desc').value.trim();
  const start=document.getElementById('view-pot-start').value;
  const end=document.getElementById('view-pot-end').value;
  const goalVal=parseFloat(document.getElementById('view-pot-goal').value);
  const targetVal=parseFloat(document.getElementById('view-pot-target').value);
  const starting=parseFloat(document.getElementById('view-pot-starting').value)||0;
  const isSplit = document.getElementById('view-pot-split').checked;
  // Update sub-pots from DOM inputs if present
  const pRef = financeData.pots[editingPotIndex] || {};
  let subPots = Array.isArray(pRef.subPots) ? pRef.subPots : [];
  if(isSplit){
    const list=document.getElementById('view-subpot-list');
    if(list){
      // Map existing by index in display order
      const rows=Array.from(list.children);
      rows.forEach((row, idx)=>{
        const sp=subPots[idx] || { id: Date.now().toString(36)+idx, label:'', goalAmount:null, assignedAmount:0 };
        const label=row.querySelector('.sp-label')?.value?.trim()||sp.label;
        const goal=parseFloat(row.querySelector('.sp-goal')?.value||'');
        sp.label=label; sp.goalAmount=isNaN(goal)?null:goal;
        subPots[idx]=sp;
      });
    }
  } else {
    subPots = [];
  }
  const pot={id:financeData.pots[editingPotIndex].id,kind,name,account,desc,start,end,goal:isNaN(goalVal)?null:goalVal,target:isNaN(targetVal)?null:targetVal,startAmount:starting,isSplit,subPots};
  if(editingPotIndex!==null){
    financeData.pots[editingPotIndex]=pot;
  }
  saveFinance();
  renderPots();
  renderTransactions();
  editingPotIndex=null;
  document.getElementById('pot-modal').style.display='none';
});
document.getElementById('close-pot-modal').addEventListener('click',()=>{
  editingPotIndex=null;
  document.getElementById('pot-modal').style.display='none';
});

document.getElementById('delete-pot').addEventListener('click',()=>{
  if(editingPotIndex!==null && confirm('Delete pot?')){
    const removed=financeData.pots.splice(editingPotIndex,1)[0];
    financeData.transactions.forEach(t=>{ if(t.potId===removed.id) t.potId=null; });
    saveFinance();
    renderPots();
    renderTransactions();
    editingPotIndex=null;
    document.getElementById('pot-modal').style.display='none';
  }
});

document.getElementById('show-duplicates').addEventListener('click', () => {
  renderDuplicates();
  document.getElementById('duplicates-modal').style.display = 'block';
});

document.getElementById('download-excel').addEventListener('click', async () => {
  const res = await fetch('/api/finance-export');
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'finance-master.xlsx';
  a.click();
  URL.revokeObjectURL(url);
});
document.getElementById('select-all').addEventListener('change', e=>{
  document.querySelectorAll('#tx-table tbody .tx-select').forEach(cb=>cb.checked=e.target.checked);
});
document.getElementById('delete-selected').addEventListener('click', ()=>{
  const ids=Array.from(document.querySelectorAll('#tx-table tbody .tx-select:checked')).map(cb=>parseInt(cb.dataset.id));
  if(!ids.length) return;
  financeData.transactions=financeData.transactions.filter(tx=>!ids.includes(tx.id));
  checkDuplicates(); // Re-check duplicates after deletion
  saveFinance();
  renderTransactions();
  renderPots();
});
document.getElementById('close-duplicates').addEventListener('click', () => {
  document.getElementById('duplicates-modal').style.display = 'none';
});

function renderDuplicates(){
  const tbody = document.querySelector('#duplicates-table tbody');
  tbody.innerHTML = '';
  financeData.transactions.filter(t=>t.duplicate).forEach(tx=>{
    const tr = document.createElement('tr');
    const keepBtn = document.createElement('button');
    keepBtn.textContent = 'Keep';
    keepBtn.addEventListener('click', ()=>{ 
      tx.duplicate=false; 
      checkDuplicates(); // Re-check all duplicates
      saveFinance(); 
      renderTransactions(); 
      renderDuplicates(); 
    });
    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', ()=>{ 
      financeData.transactions = financeData.transactions.filter(t=>t.id!==tx.id); 
      checkDuplicates(); // Re-check duplicates after deletion
      saveFinance(); 
      renderTransactions(); 
      renderPots(); 
      renderDuplicates(); 
    });
    const keepAllBtn = document.createElement('button');
    keepAllBtn.textContent = 'Keep All';
    keepAllBtn.style.background = '#17a2b8';
    keepAllBtn.style.color = 'white';
    keepAllBtn.style.border = 'none';
    keepAllBtn.style.padding = '4px 8px';
    keepAllBtn.style.margin = '2px';
    keepAllBtn.style.borderRadius = '3px';
    keepAllBtn.style.cursor = 'pointer';
    keepAllBtn.addEventListener('click', ()=>{ 
      const key = tx.date+'|'+tx.description+'|'+tx.amount+'|'+tx.accountName;
      if (!financeData.nonDuplicateGroups.includes(key)) {
        financeData.nonDuplicateGroups.push(key);
      }
      checkDuplicates(); // Re-check all duplicates
      saveFinance(); 
      renderTransactions(); 
      renderDuplicates(); 
    });
    const tdAction = document.createElement('td');
    tdAction.appendChild(keepBtn); 
    tdAction.appendChild(removeBtn);
    tdAction.appendChild(keepAllBtn);
    tr.innerHTML = `<td>${tx.date}</td><td>${tx.description}</td><td>${tx.amount}</td><td>${tx.accountName}</td><td>${tx.sourceFile}</td>`;
    tr.appendChild(tdAction);
    tbody.appendChild(tr);
  });
}

function validatePeriod(start,end,ignoreIdx=-1){
  const s=parseDate(start); const e=parseDate(end);
  if(Number.isNaN(s.getTime()) || Number.isNaN(e.getTime()) || s>e) return false;
  for(let i=0;i<financeData.budgetPeriods.length;i++){
    if(i===ignoreIdx) continue;
    const p=financeData.budgetPeriods[i];
    const ps=parseDate(p.start); const pe=parseDate(p.end);
    if(!(e<ps || s>pe)) return false;
  }
  return true;
}

function setNextPeriodStart(){
  const input=document.getElementById('period-start');
  if(!input) return;
  if(financeData.budgetPeriods.length){
    const last=financeData.budgetPeriods.slice().sort((a,b)=>parseDate(a.start)-parseDate(b.start)).pop();
    const next=new Date(parseDate(last.end).getTime()+86400000); // next day
    input.value=next.toISOString().slice(0,10);
  } else {
    input.value='';
  }
  const end=document.getElementById('period-end'); if(end) end.value='';
  const month=document.getElementById('period-month'); if(month) month.value='';
}

function renderPeriods(){
  console.log('renderPeriods called');
  const tbody=document.querySelector('#period-table tbody');
  console.log('period-table tbody found:', !!tbody);
  console.log('financeData.budgetPeriods:', financeData.budgetPeriods);
  if(!tbody) return;
  tbody.innerHTML='';
  financeData.budgetPeriods.sort((a,b)=>parseDate(a.start)-parseDate(b.start)).forEach((p,i)=>{
    const tr=document.createElement('tr');
    const actions=document.createElement('td');
    const edit=document.createElement('button'); edit.textContent='Edit';
    edit.addEventListener('click',()=>{
      const start=prompt('Start date (YYYY-MM-DD)',p.start);
      const end=prompt('End date (YYYY-MM-DD)',p.end);
      const month=prompt('Month (MM YYYY)',p.month);
      if(!start||!end||!month) return;
      if(!validatePeriod(start,end,i)){ alert('Invalid or overlapping period'); return; }
      p.start=start; p.end=end; p.month=month;
      financeData.budgetPeriods.sort((a,b)=>parseDate(a.start)-parseDate(b.start));
      assignMonthsAll();
      saveFinance();
      renderPeriods();
      populateOverviewMonths();
      populateBalanceMonths();
      populateBudgetMonths();
      renderOverview();
      renderBalance();
      renderTransactions();
    });
    const del=document.createElement('button'); del.textContent='Delete';
    del.addEventListener('click',()=>{
      financeData.budgetPeriods.splice(i,1);
      assignMonthsAll();
      saveFinance();
      renderPeriods();
      populateOverviewMonths();
      populateBalanceMonths();
      populateBudgetMonths();
      renderOverview();
      renderBalance();
      renderTransactions();
    });
    actions.appendChild(edit); actions.appendChild(del);
    tr.innerHTML=`<td>${p.start}</td><td>${p.end}</td><td>${p.month}</td>`;
    tr.appendChild(actions);
    tbody.appendChild(tr);
  });
  setNextPeriodStart();
}

function populateBudgetMonths(){
  const sel=document.getElementById('budget-month-select');
  if(!sel) return;
  
  const currentSelected = sel.value;
  const months=new Set();
  
  // Add current month
  const today = new Date();
  const currentMonth = `${String(today.getMonth()+1).padStart(2,'0')} ${today.getFullYear()}`;
  months.add(currentMonth);
  
  // Add months from budget periods
  if(financeData.budgetPeriods) {
    financeData.budgetPeriods.forEach(p=>months.add(p.month));
  }
  
  // Add months from transactions
  financeData.transactions.forEach(t=>{
    if(t.month) months.add(t.month);
  });
  
  const sortedMonths = Array.from(months).sort((a,b)=>{
    const [ma,ya]=a.split(' ').map(x=>parseInt(x));
    const [mb,yb]=b.split(' ').map(x=>parseInt(x));
    return (ya*12+ma)-(yb*12+mb);
  }).reverse(); // Most recent first
  
  sel.innerHTML='<option value="current">Current Month</option>';
  sortedMonths.forEach(m=>{
    const opt=document.createElement('option');
    opt.value=m;
    opt.textContent=`${m} ${m === currentMonth ? '(Current)' : ''}`.trim();
    sel.appendChild(opt);
  });
  
  // Restore selection if it still exists
  if(currentSelected && Array.from(sel.options).some(o=>o.value===currentSelected)) {
    sel.value = currentSelected;
  }
  
  // Add event listener if not already added
  if(!sel.hasAttribute('data-listener-added')) {
    sel.addEventListener('change', ()=>renderBudgets());
    sel.setAttribute('data-listener-added', 'true');
  }
}

function populateOverviewMonths(){
  const sel=document.getElementById('overview-month');
  if(!sel) return;
  const prev = Array.from(sel.selectedOptions).map(o=>o.value);
  const months=new Set(financeData.transactions.map(t=>t.month).filter(m=>m));
  sel.innerHTML='';
  const map={};
  financeData.budgetPeriods.forEach(p=>{map[p.month]=parseDate(p.start).getTime();});
  Array.from(months).sort((a,b)=>{
    return (map[a]||0)-(map[b]||0);
  }).forEach(m=>{
    const o=document.createElement('option');
    o.value=m;
    o.textContent=m;
    if(prev.includes(m)) o.selected=true;
    sel.appendChild(o);
  });
  if(!sel.selectedOptions.length && sel.options.length){
    sel.options[sel.options.length-1].selected=true;
  }
}

function populateBalanceMonths(){
  const sel=document.getElementById('balance-month');
  if(!sel) return;
  const prev=sel.value;
  const months=new Set(financeData.transactions.map(t=>t.month).filter(m=>m));
  financeData.budgetPeriods.forEach(p=>{ if(p.month) months.add(p.month); });
  const map={}; financeData.budgetPeriods.forEach(p=>{ map[p.month]=parseDate(p.start).getTime(); });
  sel.innerHTML='';
  Array.from(months).sort((a,b)=>{ return (map[a]||0)-(map[b]||0); }).forEach(m=>{
    const o=document.createElement('option'); o.value=m; o.textContent=m; sel.appendChild(o);
  });
  if(prev && months.has(prev)) sel.value=prev; else if(sel.options.length) sel.value=sel.options[sel.options.length-1].value;
}

function shiftMonth(month, offset){
  if(!month) return '';
  const [m,y]=month.split(' ').map(Number);
  const d=new Date(y,m-1,1);
  d.setMonth(d.getMonth()+offset);
  return `${String(d.getMonth()+1).padStart(2,'0')} ${d.getFullYear()}`;
}

function isIncomeCategory(cat){
  return /income/i.test(cat);
}

function renderStartBalances(){
  const form=document.getElementById('start-balance-form');
  if(!form) return;
  const sb=financeData.startBalances||{date:'',accounts:{}};
  document.getElementById('start-balance-date').value=sb.date||'';
  const container=document.getElementById('start-balance-accounts');
  container.innerHTML='';
  financeData.accounts.forEach(acc=>{
    const val=sb.accounts&&sb.accounts[acc]?sb.accounts[acc]:0;
    const label=document.createElement('label');
    label.textContent=acc;
    const inp=document.createElement('input'); inp.type='number'; inp.step='0.01'; inp.dataset.acc=acc; inp.value=val;
    label.appendChild(inp);
    container.appendChild(label);
  });
}

function renderBalance(){
  const sel=document.getElementById('balance-month');
  if(!sel||!sel.value) return;
  const months=[];
  for(let i=3;i>0;i--) months.push(shiftMonth(sel.value,-i));
  months.push(sel.value);
  for(let i=1;i<=3;i++) months.push(shiftMonth(sel.value,i));
  
  // Define the show variables that are used later in the function
  const showBud = document.getElementById('show-budgeted') ? document.getElementById('show-budgeted').checked : true;
  const showIncome = document.getElementById('show-income') ? document.getElementById('show-income').checked : false;
  const showRem = document.getElementById('show-remaining') ? document.getElementById('show-remaining').checked : false;
  
  const sb=financeData.startBalances||{date:'',accounts:{}};
  const startTotal=Object.values(sb.accounts||{}).reduce((s,v)=>s+parseFloat(v||0),0);
  const data={income:{},expense:{}};
  const totals={income:{actual:Array(7).fill(0),budget:Array(7).fill(0)},expense:{actual:Array(7).fill(0),budget:Array(7).fill(0)}};
  // ensure categories exist
  financeData.budgetCategories.forEach(cat=>{
    const sec=isIncomeCategory(cat)?'income':'expense';
    if(!data[sec][cat]) data[sec][cat]={subs:{},actual:Array(7).fill(0),budget:Array(7).fill(0)};
  });
  financeData.budgets.forEach(b=>{
    const sec=isIncomeCategory(b.type)?'income':'expense';
    if(!data[sec][b.type]) data[sec][b.type]={subs:{},actual:Array(7).fill(0),budget:Array(7).fill(0)};
    if(!data[sec][b.type].subs[b.name]) data[sec][b.type].subs[b.name]={actual:Array(7).fill(0),budget:Array(7).fill(0)};
  });
  financeData.transactions.filter(tx => !tx.transfer).forEach(tx=>{
    const cat=tx.type||'';
    const sub=tx.subType||'';
    const sec=parseFloat(tx.amount||0)>0?'income':'expense';
    if(!data[sec][cat]) data[sec][cat]={subs:{},actual:Array(7).fill(0),budget:Array(7).fill(0)};
    if(sub && !data[sec][cat].subs[sub]) data[sec][cat].subs[sub]={actual:Array(7).fill(0),budget:Array(7).fill(0)};
  });
  months.forEach((m,idx)=>{
    financeData.transactions.filter(t=>t.month===m && !t.transfer).forEach(t=>{
      const amt=parseFloat(t.amount||0);
      const sec=amt>0?'income':'expense';
      const val=Math.abs(amt);
      totals[sec].actual[idx]+=val;
      const cat=t.type||'';
      const sub=t.subType||'';
      if(data[sec][cat]){
        data[sec][cat].actual[idx]+=val;
        if(sub && data[sec][cat].subs[sub]) data[sec][cat].subs[sub].actual[idx]+=val;
      }
    });
    financeData.budgets.forEach(b=>{
      const amount=baseAmountForMonth(b,m)+extraForMonth(b,m);
      if(amount>0){
        const sec=isIncomeCategory(b.type)?'income':'expense';
        totals[sec].budget[idx]+=amount;
        if(data[sec][b.type]){
          data[sec][b.type].budget[idx]+=amount;
          if(data[sec][b.type].subs[b.name]) data[sec][b.type].subs[b.name].budget[idx]+=amount;
        }
      }
    });
  });
  const thead=document.querySelector('#balance-table thead');
  let head='<tr><th>Item</th>';
  months.forEach(m=>{
    const label=formatMonth(m);
    if(showBud) head+=`<th>Budgeted (${label})</th>`;
    head+=`<th>Spent (${label})</th>`;
    if(showIncome) head+=`<th>Income (${label})</th>`;
    if(showRem) head+=`<th>Remaining (${label})</th>`;
  });
  head+='<th>Status</th>';
  thead.innerHTML=head;
  const tbody=document.querySelector('#balance-table tbody');
  tbody.innerHTML='';
  const opening=[]; const closing=[];
  opening[0]=startTotal;
  const curIncome=Object.values(data.income).reduce((s,c)=>s+Math.max(c.actual[3],c.budget[3]),0);
  const curExpense=Object.values(data.expense).reduce((s,c)=>s+Math.max(c.actual[3],c.budget[3]),0);
  for(let i=0;i<7;i++){
    let net;
    if(i<3){
      net=totals.income.actual[i]-totals.expense.actual[i];
    } else if(i===3){
      net=curIncome-curExpense;
    } else {
      net=totals.income.budget[i]-totals.expense.budget[i];
    }
    closing[i]=(opening[i]||0)+net;
    if(i<6) opening[i+1]=closing[i];
  }
  const openRow=document.createElement('tr');
  openRow.innerHTML='<td>Opening Balance</td>'+opening.map(o=>`<td>${o.toFixed(2)}</td>`).join('');
  tbody.appendChild(openRow);

  function renderSection(sec){
    const secRow=document.createElement('tr');
    const totalsArr=totals[sec];
    secRow.innerHTML=`<td><button class="toggle" data-section="${sec}">+</button>${sec==='income'?'Total Income':'Total Expenditure'}</td>`+
      months.map((m,idx)=>{
        if(idx===3){ return `<td>${totalsArr.actual[idx].toFixed(2)} / ${totalsArr.budget[idx].toFixed(2)}</td>`; }
        if(idx<3){ return `<td>${totalsArr.actual[idx].toFixed(2)}</td>`; }
        return `<td>${totalsArr.budget[idx].toFixed(2)}</td>`;
      }).join('');
    tbody.appendChild(secRow);
    Object.keys(data[sec]).forEach(cat=>{
      const catRow=document.createElement('tr');
      catRow.classList.add(sec+'-cat');
      catRow.style.display='none';
      const cdata=data[sec][cat];
      catRow.innerHTML=`<td style="padding-left:20px;"><button class="toggle" data-cat="${cat.replace(/\s+/g,'-')}">+</button>${cat}</td>`+
        months.map((m,idx)=>{
          if(idx===3){ return `<td>${cdata.actual[idx].toFixed(2)} / ${cdata.budget[idx].toFixed(2)}</td>`; }
          if(idx<3){ return `<td>${cdata.actual[idx].toFixed(2)}</td>`; }
          return `<td>${cdata.budget[idx].toFixed(2)}</td>`;
        }).join('');
      tbody.appendChild(catRow);
      Object.keys(cdata.subs).forEach(sub=>{
        const srow=document.createElement('tr');
        srow.classList.add('cat-'+cat.replace(/\s+/g,'-'));
        srow.style.display='none';
        const sdata=cdata.subs[sub];
        srow.innerHTML=`<td style="padding-left:40px;">${sub}</td>`+
          months.map((m,idx)=>{
            if(idx===3){ return `<td>${sdata.actual[idx].toFixed(2)} / ${sdata.budget[idx].toFixed(2)}</td>`; }
            if(idx<3){ return `<td>${sdata.actual[idx].toFixed(2)}</td>`; }
            return `<td>${sdata.budget[idx].toFixed(2)}</td>`;
          }).join('');
        tbody.appendChild(srow);
      });
    });
  }
  renderSection('income');
  renderSection('expense');
}

function renderBalance(){
  const sel=document.getElementById('balance-month');
  if(!sel||!sel.value) return;
  
  // Get selected date range
  const rangeSelect = document.getElementById('balance-range');
  const totalMonths = rangeSelect ? parseInt(rangeSelect.value) : 7;
  const pastMonths = Math.floor((totalMonths - 1) / 2);
  const futureMonths = totalMonths - pastMonths - 1;
  
  const months = [];
  for(let i = pastMonths; i > 0; i--) months.push(shiftMonth(sel.value, -i));
  months.push(sel.value); // Current month
  for(let i = 1; i <= futureMonths; i++) months.push(shiftMonth(sel.value, i));
  
  const sb=financeData.startBalances||{date:'',accounts:{}};
  const startTotal=Object.values(sb.accounts||{}).reduce((s,v)=>s+parseFloat(v||0),0);
  
  // Clear the balance container and rebuild with 4 tables
  const balanceContainer = document.getElementById('balance-main');
  if (!balanceContainer) return;
  
  balanceContainer.innerHTML = `
    <form id="start-balance-form">
      <label>Starting Date <input type="date" id="start-balance-date"></label>
      <div id="start-balance-accounts"></div>
      <button type="submit">Save Starting Balances</button>
    </form>
    <div style="display: flex; gap: 15px; margin: 10px 0; align-items: center;">
      <label>Current Month
        <select id="balance-month"></select>
      </label>
      <label>Date Range
        <select id="balance-range" onchange="renderBalance()">
          <option value="7">7 months (3 past + current + 3 future)</option>
          <option value="5">5 months (2 past + current + 2 future)</option>
          <option value="3">3 months (1 past + current + 1 future)</option>
          <option value="12">12 months (6 past + current + 5 future)</option>
          <option value="24">24 months (12 past + current + 11 future)</option>
        </select>
      </label>
    </div>
    
    <div style="display: flex; gap: 15px; margin: 10px 0; align-items: center; padding: 10px; background-color: #f8f9fa; border-radius: 5px;">
      <span style="font-weight: bold;">Current Month Display:</span>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="radio" name="current-month-mode" value="actual" checked onchange="renderBalance()">
        <span>Actual Amounts</span>
      </label>
      <label style="display: flex; align-items: center; gap: 5px;">
        <input type="radio" name="current-month-mode" value="budget" onchange="renderBalance()">
        <span>Budget Amounts</span>
      </label>
      <small style="color: #666; margin-left: 10px;">Choose how to display the current month in the balance sheet</small>
    </div>
    
    <h3>Opening Balance</h3>
    <table id="opening-balance-table">
      <thead><tr></tr></thead>
      <tbody></tbody>
    </table>
    
    <h3>Income</h3>
    <table id="income-balance-table">
      <thead><tr></tr></thead>
      <tbody></tbody>
    </table>
    
    <h3>Expenses</h3>
    <table id="expenses-balance-table">
      <thead><tr></tr></thead>
      <tbody></tbody>
    </table>
    
    <h3>Closing Balance</h3>
    <table id="closing-balance-table">
      <thead><tr></tr></thead>
      <tbody></tbody>
    </table>
  `;
  
  // Restore the selectors with their values
  document.getElementById('balance-month').value = sel.value;
  document.getElementById('balance-range').value = totalMonths;
  
  // Set up event handlers
  setupBalanceEventHandlers();
  
  // Calculate the current month index based on actual current date, not selected month
  const today = new Date();
  const actualCurrentMonth = `${String(today.getMonth() + 1).padStart(2, '0')} ${today.getFullYear()}`;
  console.log('Actual current month:', actualCurrentMonth);
  console.log('Months array:', months);
  
  // Find where the actual current month falls in our months array
  let currentMonthIndex = -1;
  for (let i = 0; i < months.length; i++) {
    if (months[i] === actualCurrentMonth) {
      currentMonthIndex = i;
      break;
    }
  }
  
  // If actual current month isn't in the range, determine based on comparison
  if (currentMonthIndex === -1) {
    // Convert month strings to dates for comparison
    const actualDate = new Date(actualCurrentMonth.split(' ')[1], parseInt(actualCurrentMonth.split(' ')[0]) - 1, 1);
    
    for (let i = 0; i < months.length; i++) {
      const monthParts = months[i].split(' ');
      const monthDate = new Date(monthParts[1], parseInt(monthParts[0]) - 1, 1);
      
      if (actualDate < monthDate) {
        // Current month is before this month, so all months from here are future
        currentMonthIndex = i - 1;
        break;
      }
    }
    
    // If we didn't find a future month, all months are past
    if (currentMonthIndex === -1) {
      currentMonthIndex = months.length - 1;
    }
  }
  
  console.log('Calculated current month index:', currentMonthIndex);
  
  // Check if user wants to use budget amounts for current month
  const currentMonthModeInputs = document.querySelectorAll('input[name="current-month-mode"]');
  const useBudgetForCurrent = Array.from(currentMonthModeInputs).find(input => input.checked)?.value === 'budget';
  console.log('Use budget for current month:', useBudgetForCurrent);
  
  // Adjust the current month index based on user preference
  let effectiveCurrentMonthIndex = currentMonthIndex;
  if (useBudgetForCurrent && currentMonthIndex >= 0) {
    // If user wants budget for current month, reduce the index by 1
    // This makes the current month be treated as "future" (budget)
    effectiveCurrentMonthIndex = currentMonthIndex - 1;
  }
  
  console.log('Effective current month index for calculations:', effectiveCurrentMonthIndex);
  
  // Compute monthly totals by period, using sub-type aware fixed logic for the current month
  const totals = computeMonthlyTotals(months, currentMonthIndex, useBudgetForCurrent);

  // Determine which column is the starting period month for opening balance
  const startIdx = getStartingMonthIndex(months);

  // Compute rolling opening and closing balances
  const { openings, closings } = computeRollingBalances(months, startTotal, totals, startIdx);

  // Render each table using computed arrays
  renderOpeningBalance(months, openings);
  renderIncomeBalance(months, currentMonthIndex, useBudgetForCurrent);
  renderExpensesBalance(months, currentMonthIndex, useBudgetForCurrent);
  renderClosingBalance(months, closings);
}

function renderOpeningBalance(months, openings) {
  const thead = document.querySelector('#opening-balance-table thead tr');
  const tbody = document.querySelector('#opening-balance-table tbody');
  
  let headHtml = '<th>Account</th>';
  months.forEach(m => {
    headHtml += `<th>${formatMonth(m)}</th>`;
  });
  thead.innerHTML = headHtml;
  
  const row = document.createElement('tr');
  let rowHtml = '<td><strong>Opening Balance</strong></td>';
  openings.forEach(val => {
    rowHtml += `<td>${val == null ? '' : val.toFixed(2)}</td>`;
  });
  row.innerHTML = rowHtml;
  tbody.appendChild(row);
}

function renderIncomeBalance(months, actualCurrentMonthIndex, useBudgetForCurrent) {
  const thead = document.querySelector('#income-balance-table thead tr');
  const tbody = document.querySelector('#income-balance-table tbody');
  
  let headHtml = '<th>Income Category</th>';
  months.forEach(m => {
    headHtml += `<th>${formatMonth(m)}</th>`;
  });
  thead.innerHTML = headHtml;
  
  // Get all income categories
  const incomeCategories = financeData.budgetCategories.filter(cat => isIncomeCategory(cat));
  let monthlyIncomeTotals = Array(months.length).fill(0);
  
  incomeCategories.forEach(cat => {
    // Show main category only (no sub-categories)
    const catRow = document.createElement('tr');
    catRow.style.fontWeight = 'bold';
    catRow.style.backgroundColor = '#f8f9fa';
    
    let catHtml = `<td>${cat}</td>`;
    
    months.forEach((m, idx) => {
      let income = 0;
      const txs = financeData.transactions.filter(t => t.type === cat && t.month === m && !t.transfer);
      const actualIncome = txs.filter(t => parseFloat(t.amount || 0) > 0).reduce((s, t) => s + parseFloat(t.amount || 0), 0);
      const budgets = financeData.budgets.filter(b => b.type === cat && !b.archived);
      const budgetIncome = budgets.reduce((s, b) => s + baseAmountForMonth(b, m) + extraForMonth(b, m), 0);
      
      if (idx < actualCurrentMonthIndex) {
        // Past months: actual
        income = actualIncome;
      } else if (idx === actualCurrentMonthIndex) {
        // Current month: respect toggle
        income = useBudgetForCurrent ? budgetIncome : actualIncome;
      } else {
        // Future months: budget
        income = budgetIncome;
      }
      
      catHtml += `<td>${income.toFixed(2)}</td>`;
      monthlyIncomeTotals[idx] += income;
    });
    
    catRow.innerHTML = catHtml;
    tbody.appendChild(catRow);
  });
  
  // Add income totals row
  const totalsRow = document.createElement('tr');
  totalsRow.style.fontWeight = 'bold';
  totalsRow.style.borderTop = '2px solid #ccc';
  totalsRow.style.backgroundColor = '#e8f5e8';
  
  let totalsHtml = '<td><strong>TOTAL INCOME</strong></td>';
  monthlyIncomeTotals.forEach(total => {
    totalsHtml += `<td><strong>${total.toFixed(2)}</strong></td>`;
  });
  totalsRow.innerHTML = totalsHtml;
  tbody.appendChild(totalsRow);
  
  // Store for closing balance calculation (for any legacy use)
  window.monthlyIncomeTotals = monthlyIncomeTotals;
}

function renderExpensesBalance(months, actualCurrentMonthIndex, useBudgetForCurrent) {
  const thead = document.querySelector('#expenses-balance-table thead tr');
  const tbody = document.querySelector('#expenses-balance-table tbody');
  
  let headHtml = '<th>Expense Category</th>';
  months.forEach(m => {
    headHtml += `<th>${formatMonth(m)}</th>`;
  });
  thead.innerHTML = headHtml;
  
  // Get all non-income categories
  const expenseCategories = financeData.budgetCategories.filter(cat => !isIncomeCategory(cat));
  let monthlyExpenseTotals = Array(months.length).fill(0);
  
  expenseCategories.forEach(cat => {
    // Show main category only (no sub-categories)
    const catRow = document.createElement('tr');
    catRow.style.fontWeight = 'bold';
    catRow.style.backgroundColor = '#f8f9fa';
    
    let catHtml = `<td>${cat}</td>`;
    
    months.forEach((m, idx) => {
      let total = 0;
  const budgets = financeData.budgets.filter(b => b.type === cat && !b.archived);
  const budgetAmount = budgets.reduce((s, b) => s + baseAmountForMonth(b, m) + extraForMonth(b, m), 0);
      const txs = financeData.transactions.filter(t => t.type === cat && t.month === m && !t.transfer);
      const actualSum = txs.reduce((s, t) => s + parseFloat(t.amount || 0), 0);
      
      if (idx < actualCurrentMonthIndex) {
        // Past months: actual
        total = actualSum;
      } else if (idx === actualCurrentMonthIndex) {
        // Current month: per sub-budget fixed handling
        const subs = budgets;
        let magnitude = 0;
        const subNames = new Set(subs.map(s=>s.name));
        subs.forEach(sub=>{
          const subBudget = baseAmountForMonth(sub, m) + extraForMonth(sub, m);
          const subTxs = txs.filter(t=>t.subType === sub.name);
          const subActualMag = Math.abs(subTxs.reduce((s,t)=>s+parseFloat(t.amount||0),0));
          const subFixed = (typeof sub.fixed === 'boolean') ? sub.fixed : !!financeData.categoryFixed[cat];
          const subSpentMag = subFixed ? Math.max(subActualMag, subBudget) : (useBudgetForCurrent ? subBudget : subActualMag);
          magnitude += subSpentMag;
        });
        // Add any category-level untyped tx actuals
        const extraTxActualMag = Math.abs(txs.filter(t=>!t.subType || !subNames.has(t.subType)).reduce((s,t)=>s+parseFloat(t.amount||0),0));
        magnitude += extraTxActualMag;
        total = -magnitude; // expenses negative
      } else {
        // Future months: budget only
        total = -budgetAmount;
      }
      
      // Display absolute value for negative amounts, with + symbol for positive
      let displayValue;
      if (total < 0) {
        displayValue = Math.abs(total).toFixed(2);
      } else if (total > 0) {
        displayValue = `+${total.toFixed(2)}`;
      } else {
        displayValue = '0.00';
      }
      
      catHtml += `<td>${displayValue}</td>`;
  monthlyExpenseTotals[idx] += total; // Keep signed value for closing balance calculation
    });
    
    catRow.innerHTML = catHtml;
    tbody.appendChild(catRow);
  });
  
  // Add expense totals row
  const totalsRow = document.createElement('tr');
  totalsRow.style.fontWeight = 'bold';
  totalsRow.style.borderTop = '2px solid #ccc';
  totalsRow.style.backgroundColor = '#ffe8e8';
  
  let totalsHtml = '<td><strong>TOTAL EXPENSES</strong></td>';
  monthlyExpenseTotals.forEach(total => {
    let displayValue;
    if (total < 0) {
      displayValue = Math.abs(total).toFixed(2);
    } else if (total > 0) {
      displayValue = `+${total.toFixed(2)}`;
    } else {
      displayValue = '0.00';
    }
    totalsHtml += `<td><strong>${displayValue}</strong></td>`;
  });
  totalsRow.innerHTML = totalsHtml;
  tbody.appendChild(totalsRow);
  
  // Store expense totals for closing balance calculation (for any legacy use)
  window.monthlyExpenseTotals = monthlyExpenseTotals;
}

function renderClosingBalance(months, closings) {
  const thead = document.querySelector('#closing-balance-table thead tr');
  const tbody = document.querySelector('#closing-balance-table tbody');
  
  let headHtml = '<th>Balance</th>';
  months.forEach(m => {
    headHtml += `<th>${formatMonth(m)}</th>`;
  });
  thead.innerHTML = headHtml;
  
  // Calculate closing balance: Opening + Income + Expenses (with proper signs)
  const row = document.createElement('tr');
  row.style.fontWeight = 'bold';
  row.style.backgroundColor = '#f0f8ff';
  row.style.borderTop = '2px solid #333';
  
  let rowHtml = '<td><strong>Closing Balance</strong></td>';
  closings.forEach(val => {
    rowHtml += `<td><strong>${val == null ? '' : val.toFixed(2)}</strong></td>`;
  });
  
  row.innerHTML = rowHtml;
  tbody.appendChild(row);
}

// Compute income/expense totals per period month using the same rules as the UI tables
function computeMonthlyTotals(months, actualCurrentMonthIndex, useBudgetForCurrent){
  const incomeTotals = Array(months.length).fill(0);
  const expenseTotals = Array(months.length).fill(0);
  const isIncomeCategoryFn = isIncomeCategory; // reuse
  const today = new Date();
  const isCurrentMonth = (m)=>{
    const [mm,yy]=m.split(' ').map(x=>parseInt(x,10));
    return (yy===today.getFullYear()) && (mm===(today.getMonth()+1));
  };

  months.forEach((m, idx)=>{
    if(idx <= actualCurrentMonthIndex){
      // Past months always actual; for the current month apply per-sub fixed rules
      const txs = financeData.transactions.filter(t => t.month === m && !t.transfer);
      const incomeActual = txs.filter(t => parseFloat(t.amount||0) > 0).reduce((s,t)=>s+parseFloat(t.amount||0),0);
      if(idx < actualCurrentMonthIndex){
        // Past months: pure actuals
        const expenseActual = txs.reduce((s,t)=>s+parseFloat(t.amount||0),0) - incomeActual;
        incomeTotals[idx] = incomeActual;
        expenseTotals[idx] = expenseActual;
      } else {
        // Current month: income per toggle; expenses per sub fixed
        if(useBudgetForCurrent){
          // Income as budget
          const incomeCats = financeData.budgetCategories.filter(c=>isIncomeCategoryFn(c));
          const incomeBudgets = incomeCats.reduce((sum, cat)=>{
            const subs = financeData.budgets.filter(b=>b.type===cat && !b.archived);
            return sum + subs.reduce((s,b)=> s + baseAmountForMonth(b,m) + extraForMonth(b,m), 0);
          }, 0);
          incomeTotals[idx] = incomeBudgets;
        } else {
          incomeTotals[idx] = incomeActual;
        }

        // Expenses: per sub fixed max(actual, budget) at sub granularity
        const expenseCats = financeData.budgetCategories.filter(c=>!isIncomeCategoryFn(c));
        let adjustedExpense = 0; // positive magnitude
        expenseCats.forEach(cat=>{
          const subs = financeData.budgets.filter(b=>b.type===cat && !b.archived);
          const catTxs = txs.filter(t=>t.type===cat);
          const subNames = new Set(subs.map(s=>s.name));
          subs.forEach(sub=>{
            const subBudget = baseAmountForMonth(sub, m) + extraForMonth(sub, m);
            const subTxs = catTxs.filter(t=>t.subType===sub.name);
            const subActualMag = Math.abs(subTxs.reduce((s,t)=>s+parseFloat(t.amount||0),0));
            const subFixed = (typeof sub.fixed === 'boolean') ? sub.fixed : !!financeData.categoryFixed[cat];
            const subSpentMag = subFixed ? Math.max(subActualMag, subBudget) : (useBudgetForCurrent ? subBudget : subActualMag);
            adjustedExpense += subSpentMag;
          });
          // Add any category-level untyped tx actuals
          const extraTxActualMag = Math.abs(catTxs.filter(t=>!t.subType || !subNames.has(t.subType)).reduce((s,t)=>s+parseFloat(t.amount||0),0));
          adjustedExpense += extraTxActualMag;
        });
        expenseTotals[idx] = -adjustedExpense;
      }
    } else {
      // Budget: income positive; expenses negative
      const incomeCats = financeData.budgetCategories.filter(c=>isIncomeCategoryFn(c));
      const expenseCats = financeData.budgetCategories.filter(c=>!isIncomeCategoryFn(c));
      const incomeBudgets = incomeCats.reduce((sum, cat)=>{
        const subs = financeData.budgets.filter(b=>b.type===cat && !b.archived);
        return sum + subs.reduce((s,b)=> s + baseAmountForMonth(b,m) + extraForMonth(b,m), 0);
      }, 0);
      // For expenses in future months: keep as budget only (no fixed forcing for future)
      const expenseBudgets = expenseCats.reduce((sum, cat)=>{
        const subs = financeData.budgets.filter(b=>b.type===cat && !b.archived);
        const catBudget = subs.reduce((s,b)=> s + baseAmountForMonth(b,m) + extraForMonth(b,m), 0);
        return sum + catBudget;
      }, 0);
      incomeTotals[idx] = incomeBudgets;
      expenseTotals[idx] = -expenseBudgets; // negative for expenses
    }
  });
  return { incomeTotals, expenseTotals };
}

// Find the index in months[] that matches the budget period containing the Starting Date
function getStartingMonthIndex(months){
  const sb = financeData.startBalances || { date: '' };
  const sbDate = sb.date || '';
  if(!sbDate) return 0;
  const d = parseDate(sbDate);
  if(Number.isNaN(d.getTime())) return 0;
  let startMonthStr = '';
  if(financeData.budgetPeriods && financeData.budgetPeriods.length){
    const p = financeData.budgetPeriods.find(p=> d >= parseDate(p.start) && d <= parseDate(p.end));
    if(p && p.month) startMonthStr = p.month;
  }
  if(!startMonthStr){
    // Fallback to calendar month string (MM YYYY)
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const yy = d.getFullYear();
    startMonthStr = `${mm} ${yy}`;
  }
  const idx = months.indexOf(startMonthStr);
  return idx === -1 ? 0 : idx;
}

// Compute rolling opening and closing balances
function computeRollingBalances(months, startTotal, totals, startIdx){
  const openings = Array(months.length).fill(null);
  const closings = Array(months.length).fill(null);
  for(let i=0;i<months.length;i++){
    if(i < startIdx) { openings[i] = null; closings[i] = null; continue; }
    if(i === startIdx){
      openings[i] = startTotal;
    } else {
      openings[i] = closings[i-1];
    }
    const income = totals.incomeTotals[i] || 0;
    const expense = totals.expenseTotals[i] || 0;
    closings[i] = (openings[i] ?? 0) + income + expense;
  }
  return { openings, closings };
}

function setupBalanceEventHandlers() {
  // Re-populate month dropdown
  const monthSelect = document.getElementById('balance-month');
  if (monthSelect) {
    populateBalanceMonths();
    monthSelect.addEventListener('change', renderBalance);
  }
  
  // Re-populate start balance form
  renderStartBalances();
}

function debugBudgets() {
  console.log('=== BUDGET ANALYSIS ===');
  
  const sel = document.getElementById('balance-month');
  const currentMonth = sel.value;
  console.log('Current selected month:', currentMonth);
  
  // Get range info
  const rangeSelect = document.getElementById('balance-range');
  const totalMonths = rangeSelect ? parseInt(rangeSelect.value) : 7;
  const pastMonths = Math.floor((totalMonths - 1) / 2);
  const currentMonthIndex = pastMonths;
  
  console.log('Total months:', totalMonths);
  console.log('Past months:', pastMonths);
  console.log('Current month index:', currentMonthIndex);
  
  // Generate the same months array as renderBalance
  const months = [];
  for(let i = pastMonths; i > 0; i--) months.push(shiftMonth(currentMonth, -i));
  months.push(currentMonth); // Current month
  for(let i = 1; i <= totalMonths - pastMonths - 1; i++) months.push(shiftMonth(currentMonth, i));
  
  console.log('Generated months:', months);
  
  months.forEach((month, idx) => {
    console.log(`Month ${idx}: ${month} - ${idx <= currentMonthIndex ? 'ACTUAL' : 'BUDGET'}`);
  });
  
  // Test specific months
  const testMonths = ['10 2025', '11 2025']; // October and November 2025
  
  // Get Income categories
  const incomeCategories = financeData.budgetCategories.filter(cat => isIncomeCategory(cat));
  console.log('Income categories:', incomeCategories);
  
  incomeCategories.forEach(cat => {
    console.log(`\n--- Category: ${cat} ---`);
    const budgets = financeData.budgets.filter(b => b.type === cat && !b.archived);
    console.log(`Found ${budgets.length} budgets:`, budgets.map(b => b.name));
    
    budgets.forEach(budget => {
      console.log(`\n  Budget: ${budget.name}`);
      console.log('  Versions:', budget.versions?.length || 0);
      
      budget.versions?.forEach((v, i) => {
        console.log(`    Version ${i + 1}: amount=${v.amount}, start=${v.start}, end=${v.end}`);
      });
      
      testMonths.forEach(month => {
        const base = baseAmountForMonth(budget, month);
        const extra = extraForMonth(budget, month);
        console.log(`    ${month}: base=${base}, extra=${extra}, total=${base + extra}`);
      });
    });
  });
  
  console.log('=== END ANALYSIS ===');
}

function renderOverview(){
  const monthSel=document.getElementById('overview-month');
  if(!monthSel) return;
  const months=Array.from(monthSel.selectedOptions).map(o=>o.value);
  if(!months.length) return;
  const showBud=document.getElementById('show-budgeted').checked;
  const showRem=document.getElementById('show-remaining').checked;
  const showIncome=document.getElementById('show-income').checked;
  const showArch=document.getElementById('toggle-archived').checked;
  const showSubtypes=document.getElementById('show-subtypes').checked;
  const extraDisplay=document.getElementById('extra-display')?document.getElementById('extra-display').value:'merge';
  
  // Render expense table
  renderExpenseTable(months, showBud, showRem, showIncome, showArch, showSubtypes, extraDisplay);
  
  // Render income table  
  renderIncomeTable(months, showBud, showRem, showIncome, showArch, showSubtypes, extraDisplay);
}

function renderExpenseTable(months, showBud, showRem, showIncome, showArch, showSubtypes, extraDisplay) {
  const thead=document.querySelector('#overview-table thead tr');
  let headHtml='<th>Budget Item</th>';
  months.forEach(m=>{
    const label=formatMonth(m);
    if(showBud) headHtml+=`<th>Budgeted (${label})</th>`;
    headHtml+=`<th>Spent (${label})</th>`;
    if(showIncome) headHtml+=`<th>Income (${label})</th>`;
    if(showRem) headHtml+=`<th>Remaining (${label})</th>`;
  });
  headHtml+='<th>Status</th>';
  thead.innerHTML=headHtml;
  
  const tbody=document.querySelector('#overview-table tbody');
  tbody.innerHTML='';
  
  // Filter to only expense categories
  const expenseCategories = financeData.budgetCategories.filter(cat => !isIncomeCategory(cat));
  // Helper: determine if a selected month is the actual current calendar month
  const today = new Date();
  const isCurrentMonth = (m)=>{
    const [mm,yy]=m.split(' ').map(x=>parseInt(x,10));
    return (yy===today.getFullYear()) && (mm===(today.getMonth()+1));
  };
  
  expenseCategories.forEach(cat=>{
    const subs=financeData.budgets.filter(b=>b.type===cat && (showArch||!b.archived));
    const catRow=document.createElement('tr');
    catRow.style.fontWeight = 'bold';
    catRow.style.fontSize = '1.1em';
    catRow.style.backgroundColor = '#f8f9fa';
    catRow.style.borderTop = '1px solid #dee2e6';
    
    let catHtml=`<td style="font-weight: bold; color: #495057;">${cat}</td>`;
    let overallRem=0;
    months.forEach((m, idx)=>{
      let base=0, extra=0;
      subs.forEach(sub=>{ base+=baseAmountForMonth(sub,m); extra+=extraForMonth(sub,m); });
      const budget=base+extra;
      const txs=financeData.transactions.filter(t=>t.type===cat && t.month===m && !t.transfer);
      // Compute spent respecting sub-level Fixed flags (current month only)
      const isCur = isCurrentMonth(m);
      const subNames = new Set(subs.map(s=>s.name));
      let spent = 0;
      subs.forEach(sub=>{
        const subBudget = baseAmountForMonth(sub,m) + extraForMonth(sub,m);
        const subTxs = txs.filter(t=>t.subType===sub.name);
        const subActual = Math.abs(subTxs.reduce((s,t)=>s+parseFloat(t.amount||0),0));
        const subFixed = (typeof sub.fixed === 'boolean') ? sub.fixed : !!financeData.categoryFixed[cat];
        const subSpent = (isCur && subFixed) ? Math.max(subActual, subBudget) : subActual;
        spent += subSpent;
      });
      // Any tx at category level without a known subType: always count actual
      const extraTxActual = Math.abs(txs.filter(t=>!t.subType || !subNames.has(t.subType)).reduce((s,t)=>s+parseFloat(t.amount||0),0));
      spent += extraTxActual;
      
      // For expenses: how much budget left
      const rem = budget - spent;
      
      if(showBud){
        if(extraDisplay==='separate' && extra>0){
          catHtml+=`<td>${base.toFixed(2)}<div style="color:pink;font-weight:bold;font-size:0.8rem;">+${extra.toFixed(2)}</div></td>`;
        } else {
          catHtml+=`<td>${budget.toFixed(2)}</td>`;
        }
      }
      catHtml+=`<td>${spent.toFixed(2)}</td>`;
      if(showIncome) {
        // Show 0 for expense categories in income column
        catHtml+=`<td>0.00</td>`;
      }
      if(showRem) catHtml+=`<td style="color:${rem<0?'red':'green'}">${rem.toFixed(2)}</td>`;
      overallRem+=rem;
    });
    catHtml+=`<td>${overallRem>=0?'\u2705':'\u274c'}</td>`;
    catRow.innerHTML=catHtml;
    tbody.appendChild(catRow);
    
    if(showSubtypes) {
      subs.forEach(sub=>{
        const tr=document.createElement('tr');
        tr.style.backgroundColor = '#fdfdfe';
        let subHtml=`<td style="padding-left:20px; font-weight: normal; color: #6c757d; font-style: italic;">${sub.name}</td>`;
        months.forEach((m, idx)=>{
          const base=baseAmountForMonth(sub,m);
          const extra=extraForMonth(sub,m);
          const budget=base+extra;
          const txs=financeData.transactions.filter(t=>t.type===cat && t.subType===sub.name && t.month===m && !t.transfer);
          
          // Actual spent from transactions
          let spent = Math.abs(txs.reduce((s,t)=>s+parseFloat(t.amount||0),0));
          // Apply Fixed logic at sub-budget level; fallback to category if sub not fixed set
          const isCur = isCurrentMonth(m);
          const subFixed = (typeof sub.fixed === 'boolean') ? sub.fixed : !!financeData.categoryFixed[cat];
          if(isCur && subFixed){
            spent = Math.max(spent, budget);
          }
          
          // For expenses: how much budget left
          const rem = budget - spent;
          
          if(showBud){
            if(extraDisplay==='separate' && extra>0){
              subHtml+=`<td>${base.toFixed(2)}<div style="color:pink;font-weight:bold;font-size:0.8rem;">+${extra.toFixed(2)}</div></td>`;
            } else {
              subHtml+=`<td>${budget.toFixed(2)}</td>`;
            }
          }
          subHtml+=`<td>${spent.toFixed(2)}</td>`;
          if(showIncome) {
            // Show 0 for expense categories in income column
            subHtml+=`<td>0.00</td>`;
          }
          if(showRem) subHtml+=`<td style="color:${rem<0?'red':'green'}">${rem.toFixed(2)}</td>`;
        });
        subHtml+='<td></td>';
        tr.innerHTML=subHtml;
        tbody.appendChild(tr);
      });
    }
  });

  // Add expense totals row
  const totalsRow = document.createElement('tr');
  totalsRow.style.fontWeight = 'bold';
  totalsRow.style.borderTop = '2px solid #ccc';
  totalsRow.style.backgroundColor = '#f5f5f5';
  
  let totalsHtml = '<td>EXPENSE TOTALS</td>';
  
  months.forEach((m, idx) => {
    let totalBudget = 0;
    let totalSpent = 0;
    let totalRemaining = 0;
    
    // Calculate totals for each month across all expense categories only
    financeData.budgetCategories.filter(cat => !isIncomeCategory(cat)).forEach(cat => {
      const subs = financeData.budgets.filter(b => b.type === cat && (showArch || !b.archived));
      
      // Calculate total budget for this category
      let categoryBudget = 0;
      subs.forEach(sub => {
        categoryBudget += baseAmountForMonth(sub, m) + extraForMonth(sub, m);
      });
      
      // Calculate transactions for this category
      const txs = financeData.transactions.filter(t => t.type === cat && t.month === m && !t.transfer);
      
      // Calculate spent with fixed logic (sum over subs) for current month only
      const subNames = new Set(subs.map(s=>s.name));
      let categorySpent = 0;
      subs.forEach(sub => {
        const subBudget = baseAmountForMonth(sub, m) + extraForMonth(sub, m);
        const subTxs = txs.filter(t => t.subType === sub.name);
        const subActual = Math.abs(subTxs.reduce((s,t)=>s+parseFloat(t.amount||0),0));
        const subFixed = (typeof sub.fixed === 'boolean') ? sub.fixed : !!financeData.categoryFixed[cat];
        const isCur = isCurrentMonth(m);
        categorySpent += (isCur && subFixed) ? Math.max(subActual, subBudget) : subActual;
      });
      // Add any extra actuals without sub-type
      const extraTxActual = Math.abs(txs.filter(t=>!t.subType || !subNames.has(t.subType)).reduce((s,t)=>s+parseFloat(t.amount||0),0));
      categorySpent += extraTxActual;
      
      // For expenses: how much budget left
      const categoryRemaining = categoryBudget - categorySpent;
      
      totalBudget += categoryBudget;
      totalSpent += categorySpent;
      totalRemaining += categoryRemaining;
    });
    
    if (showBud) {
      totalsHtml += `<td>${totalBudget.toFixed(2)}</td>`;
    }
    totalsHtml += `<td>${totalSpent.toFixed(2)}</td>`;
    if (showIncome) totalsHtml += `<td>0.00</td>`;
    if (showRem) totalsHtml += `<td style="color:${totalRemaining < 0 ? 'red' : 'green'}">${totalRemaining.toFixed(2)}</td>`;
  });
  
  totalsHtml += '<td></td>';
  totalsRow.innerHTML = totalsHtml;
  tbody.appendChild(totalsRow);
}

function renderIncomeTable(months, showBud, showRem, showIncome, showArch, showSubtypes, extraDisplay) {
  const thead=document.querySelector('#income-table thead tr');
  let headHtml='<th>Income Item</th>';
  months.forEach(m=>{
    const label=formatMonth(m);
    if(showBud) headHtml+=`<th>Budgeted (${label})</th>`;
    headHtml+=`<th>Spent (${label})</th>`;
    if(showIncome) headHtml+=`<th>Income (${label})</th>`;
    if(showRem) headHtml+=`<th>Received (${label})</th>`; // Changed from "Remaining" to "Received"
  });
  headHtml+='<th>Status</th>';
  thead.innerHTML=headHtml;
  
  const tbody=document.querySelector('#income-table tbody');
  tbody.innerHTML='';
  
  // Filter to only income categories
  const incomeCategories = financeData.budgetCategories.filter(cat => isIncomeCategory(cat));
  
  incomeCategories.forEach(cat=>{
    const subs=financeData.budgets.filter(b=>b.type===cat && (showArch||!b.archived));
    const catRow=document.createElement('tr');
    catRow.style.fontWeight = 'bold';
    catRow.style.fontSize = '1.1em';
    catRow.style.backgroundColor = '#f8f9fa';
    catRow.style.borderTop = '1px solid #dee2e6';
    
    let catHtml=`<td style="font-weight: bold; color: #495057;">${cat}</td>`;
    let overallReceived=0;
    
    months.forEach(m=>{
      let base=0, extra=0;
      subs.forEach(sub=>{ base+=baseAmountForMonth(sub,m); extra+=extraForMonth(sub,m); });
      const budget=base+extra;
      const txs=financeData.transactions.filter(t=>t.type===cat && t.month===m && !t.transfer);
      
      // Calculate spent as absolute total of all transactions in this category
      const spent = Math.abs(txs.reduce((s,t)=>s+parseFloat(t.amount||0),0));
      
      // For income: calculate "received" as budget + actual income
      const actualIncome = txs.filter(t=>parseFloat(t.amount||0)>0).reduce((s,t)=>s+parseFloat(t.amount||0),0);
      const received = budget + actualIncome;
      
      if(showBud){
        if(extraDisplay==='separate' && extra>0){
          catHtml+=`<td>${base.toFixed(2)}<div style="color:pink;font-weight:bold;font-size:0.8rem;">+${extra.toFixed(2)}</div></td>`;
        } else {
          catHtml+=`<td>${budget.toFixed(2)}</td>`;
        }
      }
      catHtml+=`<td>${spent.toFixed(2)}</td>`;
      if(showIncome) {
        catHtml+=`<td>${actualIncome.toFixed(2)}</td>`;
      }
      if(showRem) catHtml+=`<td style="color:${received<0?'red':'green'}">${received.toFixed(2)}</td>`;
      overallReceived+=received;
    });
    catHtml+=`<td>${overallReceived>=0?'\u2705':'\u274c'}</td>`;
    catRow.innerHTML=catHtml;
    tbody.appendChild(catRow);
    
    if(showSubtypes) {
      subs.forEach(sub=>{
        const tr=document.createElement('tr');
        tr.style.backgroundColor = '#fdfdfe';
        let subHtml=`<td style="padding-left:20px; font-weight: normal; color: #6c757d; font-style: italic;">${sub.name}</td>`;
        months.forEach(m=>{
          const base=baseAmountForMonth(sub,m);
          const extra=extraForMonth(sub,m);
          const budget=base+extra;
          const txs=financeData.transactions.filter(t=>t.type===cat && t.subType===sub.name && t.month===m && !t.transfer);
          
          // Calculate spent as absolute total of all transactions for this sub-type
          const spent = Math.abs(txs.reduce((s,t)=>s+parseFloat(t.amount||0),0));
          
          // For income: calculate "received" as budget + actual income
          const actualIncome = txs.filter(t=>parseFloat(t.amount||0)>0).reduce((s,t)=>s+parseFloat(t.amount||0),0);
          const received = budget + actualIncome;
          
          if(showBud){
            if(extraDisplay==='separate' && extra>0){
              subHtml+=`<td>${base.toFixed(2)}<div style="color:pink;font-weight:bold;font-size:0.8rem;">+${extra.toFixed(2)}</div></td>`;
            } else {
              subHtml+=`<td>${budget.toFixed(2)}</td>`;
            }
          }
          subHtml+=`<td>${spent.toFixed(2)}</td>`;
          if(showIncome) {
            subHtml+=`<td>${actualIncome.toFixed(2)}</td>`;
          }
          if(showRem) subHtml+=`<td style="color:${received<0?'red':'green'}">${received.toFixed(2)}</td>`;
        });
        subHtml+='<td></td>';
        tr.innerHTML=subHtml;
        tbody.appendChild(tr);
      });
    }
  });

  // Add income totals row
  const totalsRow = document.createElement('tr');
  totalsRow.style.fontWeight = 'bold';
  totalsRow.style.borderTop = '2px solid #ccc';
  totalsRow.style.backgroundColor = '#f5f5f5';
  
  let totalsHtml = '<td>INCOME TOTALS</td>';
  
  months.forEach(m => {
    let totalBudget = 0;
    let totalSpent = 0;
    let totalIncome = 0;
    let totalReceived = 0;
    
    // Calculate totals for each month across all income categories only
    financeData.budgetCategories.filter(cat => isIncomeCategory(cat)).forEach(cat => {
      const subs = financeData.budgets.filter(b => b.type === cat && (showArch || !b.archived));
      
      // Calculate total budget for this category
      let categoryBudget = 0;
      subs.forEach(sub => {
        categoryBudget += baseAmountForMonth(sub, m) + extraForMonth(sub, m);
      });
      
      // Calculate transactions for this category
      const txs = financeData.transactions.filter(t => t.type === cat && t.month === m && !t.transfer);
      
      // Calculate spent as absolute total of all transactions
      const categorySpent = Math.abs(txs.reduce((s,t)=>s+parseFloat(t.amount||0),0));
      
      // Calculate actual income
      const categoryIncome = txs.filter(t=>parseFloat(t.amount||0)>0).reduce((s,t)=>s+parseFloat(t.amount||0),0);
      
      // For income: received = budget + actual income
      const categoryReceived = categoryBudget + categoryIncome;
      
      totalBudget += categoryBudget;
      totalSpent += categorySpent;
      totalIncome += categoryIncome;
      totalReceived += categoryReceived;
    });
    
    if (showBud) {
      totalsHtml += `<td>${totalBudget.toFixed(2)}</td>`;
    }
    totalsHtml += `<td>${totalSpent.toFixed(2)}</td>`;
    if (showIncome) totalsHtml += `<td>${totalIncome.toFixed(2)}</td>`;
    if (showRem) totalsHtml += `<td style="color:${totalReceived < 0 ? 'red' : 'green'}">${totalReceived.toFixed(2)}</td>`;
  });
  
  totalsHtml += '<td></td>';
  totalsRow.innerHTML = totalsHtml;
  tbody.appendChild(totalsRow);
}
  
function recalcPots(){
  financeData.pots.forEach(p=>{
    const start = parseFloat(p.startAmount) || 0;
    const total = financeData.transactions
      .filter(t => t.potId === p.id)
      .reduce((sum, t) => sum + (parseFloat(t.amount) || 0), 0);
    p.current = parseFloat((start + total).toFixed(2));
  });
}

function renderPots(){
  console.log('renderPots called');
  console.log('financeData.pots:', financeData.pots);
  const debtDiv=document.getElementById('debt-pots');
  const saveDiv=document.getElementById('saving-pots');
  if(!debtDiv||!saveDiv) {
    console.log('ERROR: debt-pots or saving-pots divs not found');
    return;
  }
  debtDiv.innerHTML=''; saveDiv.innerHTML='';
  
  if (!financeData.pots) {
    console.log('ERROR: financeData.pots is undefined or null');
    return;
  }
  
  console.log('About to recalc pots, pots count:', financeData.pots.length);
  recalcPots();
  financeData.pots.forEach((p,i)=>{
    const box=document.createElement('div');
    box.className='pot '+(p.kind==='saving'?'saving':'debt');
    let extra='';
    if(p.isSplit){
      const { unallocated } = getSubpotSummary(p);
      extra = `<div style="font-size:0.8rem; color:${unallocated<0?'#b00':'#333'}">Unallocated: ¬£${unallocated.toFixed(2)}</div>`;
    }
    box.innerHTML=`<div class="pot-name">${p.name}${p.isSplit?' (split)':''}</div><div>¬£${p.current.toFixed(2)}</div>${extra}`;
    const actions=document.createElement('div');
    actions.className='actions';
    const view=document.createElement('button');
    view.textContent='View';
    view.addEventListener('click',()=>openPotModal(p,i));
    actions.appendChild(view);
    box.appendChild(actions);
    if(p.kind==='saving') saveDiv.appendChild(box); else debtDiv.appendChild(box);
  });
  updateRulePotOptions();
}

// Index of the pot currently being edited (null when creating new)
let editingPotIndex = null;
function openPotModal(p,i){
  document.getElementById('view-pot-kind').value=p.kind;
  document.getElementById('view-pot-name').value=p.name;
  document.getElementById('view-pot-account').value=p.account||'';
  document.getElementById('view-pot-desc').value=p.desc||'';
  document.getElementById('view-pot-start').value=p.start||'';
  document.getElementById('view-pot-end').value=p.end||'';
  document.getElementById('view-pot-goal').value=p.goal??'';
  document.getElementById('view-pot-target').value=p.target??'';
  document.getElementById('view-pot-starting').value=p.startAmount??'';
  document.getElementById('view-pot-current').textContent=p.current.toFixed(2);
  // Split UI
  const splitCb=document.getElementById('view-pot-split');
  const wrap=document.getElementById('view-subpot-container');
  const list=document.getElementById('view-subpot-list');
  const addBtn=document.getElementById('view-add-subpot');
  splitCb.checked=!!p.isSplit;
  wrap.style.display=p.isSplit?'block':'none';
  list.innerHTML='';
  const summary = getSubpotSummary(p);
  document.getElementById('view-assigned').textContent=summary.assigned.toFixed(2);
  document.getElementById('view-unallocated').textContent=summary.unallocated.toFixed(2);
  function renderSubpots(){
    list.innerHTML='';
    (p.subPots||[]).forEach(sp=>{
      const row=document.createElement('div');
      row.style.display='grid';
      row.style.gridTemplateColumns='1fr auto auto auto auto';
      row.style.gap='6px';
      row.style.alignItems='center';
      row.innerHTML=`
        <input class="sp-label" value="${sp.label||''}" placeholder="Label">
        <span>Assigned: ¬£<strong>${(sp.assignedAmount||0).toFixed(2)}</strong></span>
        <input class="sp-goal" type="number" step="0.01" value="${sp.goalAmount??''}" placeholder="Goal">
        <button type="button" class="sp-assign">Assign‚Ä¶</button>
        <button type="button" class="sp-unassign">Unassign‚Ä¶</button>
      `;
      row.querySelector('.sp-assign').addEventListener('click',()=>{
        const amt=parseFloat(prompt('Assign amount from unallocated?')||'0');
        if(!(amt>0)) return;
        const { unallocated } = getSubpotSummary(p);
        if(amt>unallocated){ alert('Not enough unallocated funds.'); return; }
        sp.assignedAmount=(parseFloat(sp.assignedAmount)||0)+amt;
        const s=getSubpotSummary(p);
        document.getElementById('view-assigned').textContent=s.assigned.toFixed(2);
        document.getElementById('view-unallocated').textContent=s.unallocated.toFixed(2);
        saveFinance();
        renderSubpots();
        renderPots();
      });
      row.querySelector('.sp-unassign').addEventListener('click',()=>{
        const amt=parseFloat(prompt('Remove amount from this sub-pot?')||'0');
        if(!(amt>0)) return;
        if((parseFloat(sp.assignedAmount)||0) < amt){ alert('Insufficient assigned in sub-pot.'); return; }
        sp.assignedAmount=(parseFloat(sp.assignedAmount)||0)-amt;
        const s=getSubpotSummary(p);
        document.getElementById('view-assigned').textContent=s.assigned.toFixed(2);
        document.getElementById('view-unallocated').textContent=s.unallocated.toFixed(2);
        saveFinance();
        renderSubpots();
        renderPots();
      });
      row.querySelector('.sp-label').addEventListener('change',e=>{ sp.label=e.target.value; saveFinance(); renderPots(); });
      row.querySelector('.sp-goal').addEventListener('change',e=>{ const v=parseFloat(e.target.value); sp.goalAmount=isNaN(v)?null:v; saveFinance(); });
      list.appendChild(row);
    });
  }
  renderSubpots();
  if(addBtn){ addBtn.onclick=()=>{ p.subPots=p.subPots||[]; p.subPots.push({ id: Date.now().toString(36), label:'', goalAmount:null, assignedAmount:0 }); saveFinance(); renderSubpots(); } }
  splitCb.addEventListener('change',()=>{
    p.isSplit=splitCb.checked;
    wrap.style.display=p.isSplit?'block':'none';
    if(p.isSplit && (!p.subPots||!p.subPots.length)){
      p.subPots=[{ id: Date.now().toString(36), label:'', goalAmount:null, assignedAmount:0 }];
    }
    saveFinance();
    renderPots();
    renderSubpots();
  });
  const txDiv=document.getElementById('pot-transactions');
  const linked=financeData.transactions.filter(t=>t.potId===p.id);
  let html='<h3>Transactions</h3>';
  if(linked.length){
    html+='<table><thead><tr><th>Date</th><th>Description</th><th>Amount</th>'+(p.isSplit?'<th>Sub-pot</th><th>Allocate</th>':'')+'</tr></thead><tbody>';
    let total=0;
    linked.forEach(t=>{
      total+=parseFloat(t.amount)||0;
      if(p.isSplit){
        const spName = (p.subPots||[]).find(sp=>sp.id===t.subPotId)?.label || '';
        const needsAlloc = !t.subPotId;
        html+=`<tr><td>${t.date}</td><td>${t.description}</td><td>${t.amount}</td><td>${spName}</td><td>`+
          (needsAlloc?`<button data-tx="${t.id}" class="alloc-tx">Allocate‚Ä¶</button>`:'')+`</td></tr>`;
      } else {
        html+=`<tr><td>${t.date}</td><td>${t.description}</td><td>${t.amount}</td></tr>`;
      }
    });
    html+='</tbody></table>';
    html+=`<div><strong>Total from transactions:</strong> ¬£${total.toFixed(2)}</div>`;
  } else {
    html+='<p>No transactions linked</p>';
  }
  txDiv.innerHTML=html;
  // Allocation buttons for split pot
  if(p.isSplit){
    txDiv.querySelectorAll('.alloc-tx').forEach(btn=>{
      btn.addEventListener('click',()=>{
        const txId=parseInt(btn.getAttribute('data-tx'));
        const tx=financeData.transactions.find(t=>t.id===txId);
        if(!tx) return;
        // Simple allocation prompt; allow split across multiple by repeating
        const choices=(p.subPots||[]).map((sp,idx)=>`${idx+1}. ${sp.label} (assigned ¬£${(sp.assignedAmount||0).toFixed(2)})`).join('\n');
        let remaining=Math.abs(parseFloat(tx.amount)||0);
        let changed=false;
        while(remaining>0){
          const pick=prompt(`Allocate ¬£${remaining.toFixed(2)} to which sub-pot?\n${choices}\nEnter number or leave blank to stop.`);
          if(!pick) break;
          const idx=parseInt(pick)-1;
          if(idx<0 || idx>=(p.subPots||[]).length) { alert('Invalid choice'); continue; }
          const amt=parseFloat(prompt('Amount to allocate to this sub-pot?')||'0');
          if(!(amt>0) || amt>remaining){ alert('Invalid amount'); continue; }
          const sp=p.subPots[idx];
          // For positive tx amounts, increase unallocated then assign; for negative, withdraw
          if((parseFloat(tx.amount)||0) >= 0){
            // Ensure enough unallocated
            const { unallocated } = getSubpotSummary(p);
            if(amt>unallocated){ alert('Not enough unallocated funds.'); continue; }
            sp.assignedAmount=(parseFloat(sp.assignedAmount)||0)+amt;
          } else {
            // Withdraw from sub-pot
            if((parseFloat(sp.assignedAmount)||0) < amt){ alert('Insufficient assigned in sub-pot.'); continue; }
            sp.assignedAmount=(parseFloat(sp.assignedAmount)||0)-amt;
          }
          remaining-=amt;
          changed=true;
        }
        if(changed){
          // If fully allocated, set a subPotId when not split across multiple; else leave null
          // We'll not enforce single subPotId, we just handle assigned amounts as the ledger
          tx.subPotId = tx.subPotId || (p.subPots?.[0]?.id || null);
          saveFinance();
          openPotModal(p,i);
          renderPots();
        }
      });
    });
  }
  editingPotIndex=i;
  document.getElementById('pot-modal').style.display='block';
}

function resetPotForm(){
  document.getElementById('pot-form').reset();
  editingPotIndex=null;
  document.getElementById('pot-submit').textContent='Create';
  document.getElementById('subpot-container').style.display='none';
  const list=document.getElementById('subpot-list'); if(list) list.innerHTML='';
}

document.getElementById('period-form').addEventListener('submit',e=>{
  e.preventDefault();
  const start=document.getElementById('period-start').value;
  const end=document.getElementById('period-end').value;
  const monthVal=document.getElementById('period-month').value;
  const month=monthVal?`${monthVal.split('-')[1]} ${monthVal.split('-')[0]}`:'';
  if(!start||!end||!month) return;
  if(!validatePeriod(start,end)){ alert('Invalid or overlapping period'); return; }
  financeData.budgetPeriods.push({start,end,month});
  financeData.budgetPeriods.sort((a,b)=>parseDate(a.start)-parseDate(b.start));
  assignMonthsAll();
  saveFinance();
  renderPeriods();
  populateOverviewMonths();
  populateBalanceMonths();
  renderOverview();
  renderBalance();
  renderTransactions();
});

document.getElementById('overview-month')?.addEventListener('change',renderOverview);
document.getElementById('show-budgeted')?.addEventListener('change',renderOverview);
document.getElementById('show-remaining')?.addEventListener('change',renderOverview);
document.getElementById('show-income')?.addEventListener('change',renderOverview);
document.getElementById('toggle-archived')?.addEventListener('change',renderOverview);
document.getElementById('show-subtypes')?.addEventListener('change',renderOverview);
document.getElementById('extra-display')?.addEventListener('change',renderOverview);
document.getElementById('balance-month')?.addEventListener('change',renderBalance);
document.getElementById('start-balance-form').addEventListener('submit',e=>{
  e.preventDefault();
  const date=document.getElementById('start-balance-date').value;
  const accounts={};
  document.querySelectorAll('#start-balance-accounts input').forEach(inp=>{
    accounts[inp.dataset.acc]=parseFloat(inp.value||0);
  });
  financeData.startBalances={date,accounts};
  saveFinance();
  renderBalance();
});
document.addEventListener('click',e=>{
  if(e.target.classList.contains('toggle')){
    if(e.target.dataset.section){
      const rows=document.querySelectorAll('.'+e.target.dataset.section+'-cat');
      const show=e.target.textContent==='+';
      rows.forEach(r=>{r.style.display=show?'':'none';});
      e.target.textContent=show?'-':'+';
    } else if(e.target.dataset.cat){
      const rows=document.querySelectorAll('.cat-'+e.target.dataset.cat);
      const show=e.target.textContent==='+';
      rows.forEach(r=>{r.style.display=show?'':'none';});
      e.target.textContent=show?'-':'+';
    }
  }
});

// Section toggle and pin functionality (copied from index.html)
var pinnedSections = JSON.parse(localStorage.getItem('finance-pinnedSections') || '[]');

function toggle(sectionId) {
  const section = document.getElementById(sectionId);
  if (!section) return;
  
  const isPinned = pinnedSections.includes(sectionId);
  if (isPinned) return; // Don't toggle if pinned
  
  section.classList.toggle('hidden');
}

function togglePin(sectionId) {
  const pinStar = document.querySelector(`[onclick*="togglePin('${sectionId}')"]`);
  const section = document.getElementById(sectionId);
  
  if (pinnedSections.includes(sectionId)) {
    // Unpin - star becomes black, section will be closed by default on next load
    pinnedSections = pinnedSections.filter(id => id !== sectionId);
    pinStar.classList.remove('pinned');
    pinStar.title = 'Pin section open';
  } else {
    // Pin - star becomes white, section will be open by default on next load
    pinnedSections.push(sectionId);
    pinStar.classList.add('pinned');
    pinStar.title = 'Unpin section';
    section.style.display = 'block'; // Ensure pinned sections are visible
  }
  
  localStorage.setItem('finance-pinnedSections', JSON.stringify(pinnedSections));
}

// Initialize sections on page load based on pin status
function initializePinnedSections() {
  document.querySelectorAll('.section-header .pin-star').forEach(pinStar => {
    const onclickAttr = pinStar.getAttribute('onclick');
    if (onclickAttr) {
      const match = onclickAttr.match(/togglePin\('([^']+)'\)/);
      if (match) {
        const sectionId = match[1];
        const section = document.getElementById(sectionId);
        
        if (pinnedSections.includes(sectionId)) {
          // White star = pinned = open by default
          pinStar.classList.add('pinned');
          pinStar.title = 'Unpin section';
          if (section) section.classList.remove('hidden');
        } else {
          // Black star = not pinned = open by default (sections start open)
          pinStar.classList.remove('pinned');
          pinStar.title = 'Pin section open';
          // Don't automatically hide sections on page load - let them stay open
        }
      }
    }
  });
}

// Call initialization when page loads
window.addEventListener('DOMContentLoaded', initializePinnedSections);

</script>
</body>
</html>